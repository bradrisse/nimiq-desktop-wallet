{"version":3,"sources":["Class.js","PlatformUtils.js","LogNative.js","Log.js","IWorker.js","Crypto.js","CryptoWorker.js","CryptoWorkerImpl.js","NumberUtils.js","BufferUtils.js","SerialBuffer.js","MinerWorker.js","MinerWorkerImpl.js","MinerWorkerPool.js","ArrayUtils.js","Assert.js","MerkleTree.js","MerklePath.js","Policy.js","Primitive.js","Hash.js","PublicKey.js","Signature.js","Address.js","Account.js","PrunedAccount.js","BasicAccount.js","Contract.js","HashedTimeLockedContract.js","VestingContract.js","BlockHeader.js","BlockInterlink.js","BlockBody.js","BlockUtils.js","Block.js","Transaction.js","SignatureProof.js","BasicTransaction.js","ExtendedTransaction.js"],"names":["Class","[object Object]","cls","exports","name","register","PlatformUtils","window","isBrowser","process","require","RTCPeerConnection","webkitRTCPeerConnection","navigator","onLine","LogNative","this","_global_level","Log","INFO","_tag_levels","localStorage","c","getItem","JSON","parse","e","console","warn","tag","level","setItem","stringify","args","isLoggable","unshift","Level","toStringTag","Date","toTimeString","substr","error","ERROR","apply","WARNING","info","debug","DEBUG","trace","TRACE","log","instance","_instance","native","_native","setLoggable","l","i","length","toString","constructor","msg","message","arguments","Array","prototype","slice","call","undefined","VERBOSE","ASSERT","d","bind","v","w","t","IWorker","clazz","worker","Proxy","workerScript","_workersSupported","Nimiq","_path","createProxy","Worker","URL","createObjectURL","Blob","replace","_workerImplementation","init","size","Pool","startWorkerForProxy","start","data","command","res","self","postMessage","status","result","id","areWorkersAsync","_insideWebWorker","WorkerGlobalScope","_global","global","baseClazz","impl","onmessage","stubBaseOnMessage","module","_moduleLoadedCallbacks","url","resolve","head","document","getElementsByTagName","script","createElement","type","src","ret","setTimeout","onreadystatechange","onload","appendChild","proxyClass","super","_name","_messageId","_worker","_receive","_waiting","Map","_invoke","then","cb","get","delete","WorkerProxy","wasm","Promise","obj","set","funcName","Object","getOwnPropertyNames","Stub","finalRes","_result","asm","__dirname","indexOf","moduleSettings","async","reject","preRun","push","importScripts","_loadBrowserScript","WebAssembly","isNodeJs","toUint8Array","buf","u","Uint8Array","readFile","err","wasmBinary","xhr","XMLHttpRequest","open","responseType","response","onerror","send","_onmessage","close","poolClass","proxyInitializer","_proxyInitializer","_poolSize","_workers","_freeWorkers","_waitingCalls","_updateToSize","poolSize","_size","catch","shift","_step","destroy","workerPromises","createdWorkers","all","pop","idx","splice","Crypto","lib","CryptoLib","CryptoWorker","_workerSync","Error","_workerAsync","startWorkerPoolForProxy","publicKeyType","publicKeySize","key","privateKey","_cryptoWorkerSync","publicKeyDerive","privateKeyType","privateKeySize","getRandomValues","keyPairType","keyPairDerive","privateKeyGenerate","publicKey","signatureType","signatureSize","arr","signatureCreate","signature","signatureVerify","block","transactionValid","timeNow","_cryptoWorkerAsync","blockVerify","Block","GENESIS","HASH","serialize","hashType","hashSize","blake2bSize","computeBlake2b","argon2dSize","computeArgon2d","sha256Size","computeSha256","randomnessSize","commitmentPairType","randomness","commitmentCreate","secret","commitment","randomSecretType","randomSecretSize","commitmentType","commitmentSize","partialSignatureType","partialSignatureSize","publicKeys","publicKeysHash","publicKeyDelinearize","privateKeyDelinearize","publicKeysDelinearizeAndAggregate","combinedCommitment","delinearizedPartialSignatureCreate","commitments","commitmentsAggregate","partialSignatures","reduce","sigA","sigB","scalarsAdd","combinedSignature","aggregatePartialSignatures","BufferUtils","concatTypedArrays","salt","iterations","kdf","headers","partitions","j","promises","part","computeArgon2dBatch","pows","a","b","_pow","Hash","input","inputs","aggregateCommitment","genesisHash","ARGON2_HASH_SIZE","BLAKE2_HASH_SIZE","SHA256_HASH_SIZE","PUBLIC_KEY_SIZE","PRIVATE_KEY_SIZE","MULTISIG_RANDOMNESS_SIZE","SIGNATURE_SIZE","PARTIAL_SIGNATURE_SIZE","SIGNATURE_HASH_SIZE","CryptoWorkerImpl","_superInit","importWasm","importScript","memoryStart","Module","_get_static_memory_start","memorySize","_get_static_memory_size","byteOffset","_pubKeyPointer","_pubKeyBuffer","HEAP8","buffer","_privKeyPointer","_privKeyBuffer","_signaturePointer","_signatureBuffer","_messagePointer","_messageBuffer","stackPtr","stackSave","wasmOut","stackAlloc","wasmIn","HEAPU8","_nimiq_blake2","hash","stackRestore","_nimiq_argon2","hashes","stackTmp","_nimiq_sha256","wasmSalt","_nimiq_kdf","byteLength","_ed25519_public_key_derive","fill","wasmOutCommitment","wasmOutSecret","_ed25519_create_commitment","wasmOutSum","wasmInA","wasmInB","_ed25519_add_scalars","sum","some","concatenatedCommitments","wasmInCommitments","_ed25519_aggregate_commitments","aggCommitments","concatenatedPublicKeys","wasmInPublicKeys","_ed25519_hash_public_keys","hashedPublicKey","wasmInPublicKey","wasmInPublicKeysHash","_ed25519_delinearize_public_key","delinearizedPublicKey","_ed25519_aggregate_delinearized_public_keys","aggregatePublicKey","wasmInPrivateKey","_ed25519_derive_delinearized_private_key","delinearizedPrivateKey","wasmInSecret","wasmInCommitment","wasmInMessage","_ed25519_delinearized_partial_sign","partialSignature","messageLength","_ed25519_sign","_ed25519_verify","blockSerialized","unserialize","SerialBuffer","body","transactions","_valid","valid","_verify","pow","header","interlinkHash","interlink","bodyHash","prepareForWorkerUse","NumberUtils","val","Number","isInteger","UINT8_MAX","UINT16_MAX","UINT32_MAX","UINT64_MAX","Math","floor","random","MAX_SAFE_INTEGER","String","fromCharCode","string","charCodeAt","u8","TextDecoder","_ISO_8859_15_DECODER","decode","num","_BASE64_LOOKUP","end","tmp","output","_tripletToBase64","join","len","extraBytes","parts","len2","_base64encodeChunk","Buffer","btoa","_codePointTextDecoder","_base64fromByteArray","base64","from","atob","toBase64","alphabet","BASE32_ALPHABET","NIMIQ","byte","symbol","carry","base32","charmap","toUpperCase","split","forEach","char","hex","code","HEX_ALPHABET","trim","StringUtils","isHexBytes","match","parseInt","viewA","viewB","BASE64_ALPHABET","RFC4648","RFC4648_HEX","bufferOrArrayOrLength","_view","DataView","_readPos","_writePos","ArrayUtils","subarray","readPos","value","writePos","array","getUint8","setUint8","getUint16","setUint16","getUint32","setUint32","isUint64","readUint8","readUint16","readUint32","readUint64","writeUint8","writeUint16","writeUint32","writeUint64","getFloat64","setFloat64","bytes","read","toAscii","isMultibyte","fromAscii","write","view","padding","isUint8","MinerWorker","blockHeader","compact","minNonce","maxNonce","MinerWorkerImpl","_malloc","nonce","_nimiq_argon2_target","_free","MinerWorkerPool","_miningEnabled","_activeNonces","_block","_noncesPerRun","_observable","Observable","_shareCompact","Policy","BLOCK_TARGET_MAX","_runsPerCycle","Infinity","_cycleWait","_superUpdateToSize","nimiq_node","multiMine","fail","nimiq_argon2_target_async","argon2d","noncesPerRun","nonces","runsPerCycle","cycleWait","callback","on","off","shareCompact","nBits","_startMiner","max","map","nonceRange","_singleMiner","fire","newMin","newRange","uintarr","begin","clamp","min","list","k","n","indices","x","reverseRange","found","Assert","condition","MerkleTree","values","fnHash","_hash","_computeRoot","light","mid","round","left","right","leftHash","rightHash","o","MerklePath","nodes","isArray","it","MerklePathNode","_nodes","leafValue","leafHash","path","_compute","containsLeaf","inner","equals","leftLeaf","rightLeaf","root","node","concat","serializedSize","count","leftBitsSize","ceil","leftBits","_compress","every","_left","coins","SATOSHIS_PER_COIN","satoshis","blockHeight","startHeight","_supplyCacheInterval","startI","_supplyCacheMax","endI","supply","INITIAL_SUPPLY","_supplyCache","endHeight","_supplyAfter","initialSupply","_blockRewardAt","currentSupply","supplyAfter","remaining","TOTAL_SUPPLY","EMISSION_TAIL_START","EMISSION_TAIL_REWARD","EMISSION_SPEED","BLOCK_TIME","BLOCK_SIZE_MAX","DIFFICULTY_BLOCK_WINDOW","DIFFICULTY_MAX_ADJUSTMENT_FACTOR","TRANSACTION_VALIDITY_WINDOW","M","K","DELTA","NUM_BLOCKS_VERIFICATION","NUM_SNAPSHOTS_MAX","Primitive","arg","_obj","compare","toHex","algorithm","Algorithm","BLAKE2B","getSize","_algorithm","blake2b","blake2bSync","blake2bAsync","ARGON2D","sha256","SHA256","SIZE","fromBase64","fromHex","str","NULL","PublicKey","sort","delinearizeAndAggregatePublicKeys","publicKeyUnserialize","publicKeySerialize","lightAsync","Address","fromHash","PeerId","Signature","signatures","combinePartialSignatures","s","signatureUnserialize","signatureSerialize","SERIALIZED_SIZE","fromUserFriendlyAddress","CCODE","_ibanCheck","fromBase32","withSpaces","toBase32","check","HEX_SIZE","CONTRACT_CREATION","Account","balance","_type","_balance","TYPE_MAP","has","transaction","transactionsCache","revert","validityStartHeight","withBalance","fee","newBalance","containsTransaction","INITIAL","isInitial","Type","BASIC","VESTING","HTLC","PrunedAccount","address","account","_address","_account","BasicAccount","SignatureProof","verifyTransaction","hasFlag","Transaction","Flag","recipientType","withIncomingTransaction","create","Contract","recipient","getContractCreationAddress","HashedTimeLockedContract","sender","hashRoot","hashCount","timeout","totalAmount","isUint32","_sender","_recipient","_hashRoot","_hashCount","_timeout","_totalAmount","hashAlgorithm","toUserFriendlyAddress","proof","ProofType","REGULAR_TRANSFER","hashDepth","preImage","compute","verify","serializeContent","EARLY_RESOLVE","TIMEOUT_RESOLVE","verifyIncomingTransaction","minCap","isSignedBy","withOutgoingTransaction","VestingContract","owner","vestingStart","vestingStepBlocks","vestingStepAmount","vestingTotalAmount","_owner","_vestingStart","_vestingStepBlocks","_vestingStepAmount","_vestingTotalAmount","getMinCap","BlockHeader","prevHash","copy","_prevHash","_interlinkHash","_bodyHash","accountsHash","_accountsHash","_nBits","_height","_timestamp","_nonce","_version","height","timestamp","version","CURRENT_VERSION","isUint16","isHash","BlockUtils","isValidCompact","SUPPORTED_VERSIONS","includes","isProofOfWork","target","prevHeader","hard","compactToTarget","difficulty","compactToDifficulty","Version","V1","BlockInterlink","_hashes","repeatBits","_repeatBits","compressed","_compressed","repeatBitsSize","lastHash","computeRoot","BlockBody","extraData","minerAddr","prunedAccounts","_minerAddr","_extraData","_transactions","_prunedAccounts","extraDataLength","numTransactions","numPrunedAccounts","tx","acc","previousTx","compareBlockOrder","previousAcc","isToBePruned","getMerkleLeafs","addresses","transactionCount","isFinite","isNaN","log2","getTargetHeight","targetToCompact","difficultyToTarget","targetToDifficulty","hashToTarget","isValidTarget","headBlock","tailBlock","deltaTotalDifficulty","that","actualTime","adjustment","averageDifficulty","nextTarget","_header","_interlink","_body","time","isLight","now","TIMESTAMP_DRIFT_MAX","verifyProofOfWork","_verifyInterlink","isFull","_verifyBody","predecessor","isImmediateSuccessorOf","getNextInterlink","prevPow","targetHeight","blockFound","depth","HashSet","addAll","removeAll","depthDiff","getTargetDepth","commonBlock","thisInterlink","prevInterlink","isInterlinkSuccessorOf","nextVersion","thisPowDepth","nextTargetDepth","hashAsync","format","senderType","flags","_format","_senderType","_recipientType","_value","_fee","_validityStartHeight","_flags","_data","_proof","FORMAT_MAP","serializedContentSize","verifyOutgoingTransaction","recCompare","senderCompare","feePerByte","flag","Format","EXTENDED","NONE","ALL","signerKey","merklePath","_publicKey","_merklePath","_signature","merkleRoot","BasicTransaction","senderPubKey","singleSig","toAddress","_signatureProof","ExtendedTransaction","dataSize","proofSize"],"mappings":"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","file":"worker.js","sourcesContent":["class Class {\n    static register(cls) {\n        if (typeof exports !== 'undefined') exports[cls.name] = cls;\n    }\n}\nClass.register(Class);\n","class PlatformUtils {\n    /**\n     * @returns {boolean}\n     */\n    static isBrowser() {\n        return typeof window !== 'undefined';\n    }\n\n    /**\n     * @return {boolean}\n     */\n    static isNodeJs() {\n        return !PlatformUtils.isBrowser() && typeof process === 'object' && typeof require === 'function';\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    static supportsWebRTC() {\n        let RTCPeerConnection = PlatformUtils.isBrowser() ? (window.RTCPeerConnection || window.webkitRTCPeerConnection) : null;\n        return !!RTCPeerConnection;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    static isOnline() {\n        return (!PlatformUtils.isBrowser() || !('onLine' in window.navigator)) || window.navigator.onLine;\n    }\n}\nClass.register(PlatformUtils);\n","class LogNative {\n    constructor() {\n        this._global_level = Log.INFO;\n        this._tag_levels = {};\n        try {\n            if (window.localStorage) {\n                try {\n                    let c = window.localStorage.getItem('log_tag_levels');\n                    if (c && typeof c === 'string') c = JSON.parse(c);\n                    if (c && typeof c === 'object') this._tag_levels = c;\n                } catch (e) {\n                    console.warn('Failed to load log configuration from local storage.');\n                }\n            }\n        } catch (e) {\n            // ignore\n        }\n    }\n\n    isLoggable(tag, level) {\n        if (tag && this._tag_levels[tag]) {\n            return this._tag_levels[tag] <= level;\n        }\n        if (this._tag_levels['*']) {\n            return this._tag_levels['*'] <= level;\n        }\n        return this._global_level <= level;\n    }\n\n    setLoggable(tag, level) {\n        if (tag && tag.name) tag = tag.name;\n        this._tag_levels[tag] = level;\n        if (window.localStorage) {\n            window.localStorage.setItem('log_tag_levels', JSON.stringify(this._tag_levels));\n        }\n    }\n\n    msg(level, tag, args) {\n        if (tag && tag.name) tag = tag.name;\n        if (!this.isLoggable(tag, level)) return;\n        if (tag) args.unshift(tag + ':');\n        args.unshift(`[${Log.Level.toStringTag(level)} ${new Date().toTimeString().substr(0, 8)}]`);\n        if (console.error && level >= Log.ERROR) {\n            console.error.apply(console, args);\n        } else if (console.warn && level >= Log.WARNING) {\n            console.warn.apply(console, args);\n        } else if (console.info && level >= Log.INFO) {\n            console.info.apply(console, args);\n        } else if (console.debug && level >= Log.DEBUG) {\n            console.debug.apply(console, args);\n        } else if (console.trace && level <= Log.TRACE) {\n            console.trace.apply(console, args);\n        } else {\n            console.log.apply(console, args);\n        }\n    }\n}\nClass.register(LogNative);\n","class Log {\n    /**\n     * @returns {Log}\n     */\n    static get instance() {\n        if (!Log._instance) {\n            Log._instance = new Log(new LogNative());\n        }\n        return Log._instance;\n    }\n\n    /**\n     * @param {LogNative} native\n     */\n    constructor(native) {\n        /** @type {LogNative} */\n        this._native = native;\n    }\n\n    /**\n     * @param {string} tag\n     * @param {Log.Level} level\n     */\n    setLoggable(tag, level) {\n        this._native.setLoggable(tag, level);\n    }\n\n    /** @type {Log.Level} */\n    get level() {\n        return this._native._global_level;\n    }\n\n    /** @type {Log.Level} */\n    set level(l) {\n        this._native._global_level = l;\n    }\n\n    /**\n     * @param {Log.Level} level\n     * @param {string|{name:string}} tag\n     * @param {Array} args\n     */\n    msg(level, tag, args) {\n        if (this._native.isLoggable(tag, level)) {\n            for (let i = 0; i < args.length; ++i) {\n                if (typeof args[i] === 'function') {\n                    args[i] = args[i]();\n                }\n                if (typeof args[i] === 'object') {\n                    if (typeof args[i].toString === 'function') {\n                        args[i] = args[i].toString();\n                    } else if (args[i].constructor && args[i].constructor.name) {\n                        args[i] = `{Object: ${args[i].constructor.name}}`;\n                    } else {\n                        args[i] = '{Object}';\n                    }\n                }\n            }\n            this._native.msg(level, tag, args);\n        }\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static d(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.DEBUG, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static e(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.ERROR, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static i(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.INFO, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static v(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.VERBOSE, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static w(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.WARNING, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static t(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.TRACE, tag, args);\n    }\n}\n/**\n * @enum {number}\n */\nLog.Level = {\n    TRACE: 1,\n    VERBOSE: 2,\n    DEBUG: 3,\n    INFO: 4,\n    WARNING: 5,\n    ERROR: 6,\n    ASSERT: 7,\n\n    /**\n     * @param {Log.Level} level\n     */\n    toStringTag: function (level) {\n        switch (level) {\n            case Log.TRACE:\n                return 'T';\n            case Log.VERBOSE:\n                return 'V';\n            case Log.DEBUG:\n                return 'D';\n            case Log.INFO:\n                return 'I';\n            case Log.WARNING:\n                return 'W';\n            case Log.ERROR:\n                return 'E';\n            case Log.ASSERT:\n                return 'A';\n            default:\n                return '*';\n        }\n    }\n};\nLog.TRACE = Log.Level.TRACE;\nLog.VERBOSE = Log.Level.VERBOSE;\nLog.DEBUG = Log.Level.DEBUG;\nLog.INFO = Log.Level.INFO;\nLog.WARNING = Log.Level.WARNING;\nLog.ERROR = Log.Level.ERROR;\nLog.ASSERT = Log.Level.ASSERT;\nLog._instance = null;\n\nLog.d.tag = (tag) => Log.d.bind(null, tag);\nLog.e.tag = (tag) => Log.e.bind(null, tag);\nLog.i.tag = (tag) => Log.i.bind(null, tag);\nLog.v.tag = (tag) => Log.v.bind(null, tag);\nLog.w.tag = (tag) => Log.w.bind(null, tag);\nLog.t.tag = (tag) => Log.t.bind(null, tag);\n\nClass.register(Log);\n","/**\n * @interface\n */\nclass IWorker {\n    static async createProxy(clazz, name, worker) {\n        return new (IWorker.Proxy(clazz))(worker, name);\n    }\n\n    static async startWorkerForProxy(clazz, name, workerScript) {\n        if (!IWorker._workersSupported) {\n            await IWorker._workerImplementation[clazz.name].init(name);\n            return IWorker._workerImplementation[clazz.name];\n        } else {\n            if (!workerScript) {\n                workerScript = `${Nimiq._path}worker.js`;\n            }\n            return IWorker.createProxy(clazz, name, new Worker(window.URL.createObjectURL(new Blob([`Nimiq = {_path: '${Nimiq._path}'}; importScripts('${workerScript.replace(/'/g, '')}');`]))));\n        }\n    }\n\n    static async startWorkerPoolForProxy(clazz, name, size, workerScript) {\n        return (new (IWorker.Pool(clazz))((name) => IWorker.startWorkerForProxy(clazz, name, workerScript), name, size)).start();\n    }\n\n    static async stubBaseOnMessage(msg) {\n        try {\n            if (msg.data.command === 'init') {\n                if (IWorker._workerImplementation[msg.data.args[0]]) {\n                    const res = await IWorker._workerImplementation[msg.data.args[0]].init(msg.data.args[1]);\n                    self.postMessage({status: 'OK', result: res, id: msg.data.id});\n                } else {\n                    self.postMessage({status: 'error', result: 'Unknown worker!', id: msg.data.id});\n                }\n            } else {\n                self.postMessage({status: 'error', result: 'Worker not yet initialized!', id: msg.data.id});\n            }\n        } catch (e) {\n            self.postMessage({status: 'error', result: e, id: msg.data.id});\n        }\n    }\n\n    static get _workersSupported() {\n        return typeof Worker !== 'undefined';\n    }\n\n    static get areWorkersAsync() {\n        return IWorker._workersSupported;\n    }\n\n    static get _insideWebWorker() {\n        return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;\n    }\n\n    static get _global() {\n        return typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : null;\n    }\n\n    static prepareForWorkerUse(baseClazz, impl) {\n        if (IWorker._insideWebWorker) {\n            // Only inside WebWorker\n            self.onmessage = IWorker.stubBaseOnMessage;\n        }\n        IWorker._workerImplementation = IWorker._workerImplementation || {};\n        IWorker._workerImplementation[baseClazz.name] = impl;\n    }\n\n    static fireModuleLoaded(module = 'Module') {\n        if (typeof IWorker._moduleLoadedCallbacks[module] === 'function') {\n            IWorker._moduleLoadedCallbacks[module]();\n            IWorker._moduleLoadedCallbacks[module] = null;\n        }\n    }\n\n    static _loadBrowserScript(url, resolve) {\n        // Adding the script tag to the head as suggested before\n        const head = document.getElementsByTagName('head')[0];\n        const script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.src = url;\n\n        // Then bind the event to the callback function.\n        // There are several events for cross browser compatibility.\n        // These events might occur before processing, so delay them a bit.\n        const ret = () => window.setTimeout(resolve, 100);\n        script.onreadystatechange = ret;\n        script.onload = ret;\n\n        // Fire the loading\n        head.appendChild(script);\n    }\n\n    static Proxy(clazz) {\n        const proxyClass = class extends clazz {\n            /**\n             * @param {Worker} worker\n             * @param {string} [name]\n             */\n            constructor(worker, name) {\n                super();\n                this._name = name;\n                this._messageId = 0;\n                this._worker = worker;\n                this._worker.onmessage = this._receive.bind(this);\n                /** @type {Map.<number,{resolve:Function,error:Function}>} */\n                this._waiting = new Map();\n                return this._invoke('init', [clazz.name, name]).then(() => { return this; });\n            }\n\n            _receive(msg) {\n                const cb = this._waiting.get(msg.data.id);\n                if (!cb) {\n                    Log.w(WorkerProxy, 'Unknown reply', msg);\n                } else {\n                    this._waiting.delete(msg.data.id);\n                    if (msg.data.status === 'OK') {\n                        cb.resolve(msg.data.result);\n                    } else if (msg.data.status === 'error') {\n                        cb.error(msg.data.result);\n                    }\n                }\n            }\n\n            /**\n             * @param {string} script\n             * @returns {Promise.<boolean>}\n             */\n            importScript(script) {\n                return this._invoke('importScript', [script]);\n            }\n\n            /**\n             * @param {string} wasm\n             * @param {string} module\n             * @returns {Promise.<boolean>}\n             */\n            importWasm(wasm, module = 'Module') {\n                return this._invoke('importWasm', [wasm, module]);\n            }\n\n            /**\n             * @param {string} command\n             * @param {object[]} [args]\n             * @returns {Promise}\n             * @private\n             */\n            _invoke(command, args = []) {\n                return new Promise((resolve, error) => {\n                    const obj = {command: command, args: args, id: this._messageId++};\n                    this._waiting.set(obj.id, {resolve, error});\n                    this._worker.postMessage(obj);\n                });\n            }\n\n            destroy() {\n                return this._invoke('destroy');\n            }\n        };\n        for (const funcName of Object.getOwnPropertyNames(clazz.prototype)) {\n            if (typeof clazz.prototype[funcName] === 'function' && funcName !== 'constructor') {\n                proxyClass.prototype[funcName] = function (...args) {\n                    return this._invoke(funcName, args);\n                };\n            }\n        }\n        return proxyClass;\n    }\n\n    /**\n     * @param {object} clazz\n     * @return {Stub}\n     * @constructor\n     */\n    static Stub(clazz) {\n        const Stub = class extends clazz {\n            constructor() {\n                super();\n            }\n\n            _result(msg, status, result) {\n                self.postMessage({status, result, id: msg.data.id});\n            }\n\n            _onmessage(msg) {\n                try {\n                    const res = this._invoke(msg.data.command, msg.data.args);\n                    if (res instanceof Promise) {\n                        res.then((finalRes) => { this._result(msg, 'OK', finalRes); });\n                    } else {\n                        this._result(msg, 'OK', res);\n                    }\n                } catch (e) {\n                    this._result(msg, 'error', e.message || e);\n                }\n            }\n\n            importScript(script, module = 'Module') {\n                if (module && IWorker._global[module] && IWorker._global[module].asm) return false;\n                if (typeof Nimiq !== 'undefined' && Nimiq._path) script = `${Nimiq._path}${script}`;\n                if (typeof __dirname === 'string' && script.indexOf('/') === -1) script = `${__dirname}/${script}`;\n\n                const moduleSettings = IWorker._global[module] || {};\n                return new Promise(async (resolve, reject) => {\n                    if (module) {\n                        switch (typeof moduleSettings.preRun) {\n                            case 'undefined':\n                                moduleSettings.preRun = () => resolve(true);\n                                break;\n                            case 'function':\n                                moduleSettings.preRun = [moduleSettings, () => resolve(true)];\n                                break;\n                            case 'object':\n                                moduleSettings.preRun.push(() => resolve(true));\n                        }\n                    }\n                    if (typeof importScripts === 'function') {\n                        await new Promise((resolve) => {\n                            IWorker._moduleLoadedCallbacks[module] = resolve;\n                            importScripts(script);\n                        });\n                        IWorker._global[module] = IWorker._global[module](moduleSettings);\n                        if (!module) resolve(true);\n                    } else if (typeof window === 'object') {\n                        await new Promise((resolve) => {\n                            IWorker._loadBrowserScript(script, resolve);\n                        });\n                        IWorker._global[module] = IWorker._global[module](moduleSettings);\n                        if (!module) resolve(true);\n                    } else if (typeof require === 'function') {\n                        IWorker._global[module] = require(script)(moduleSettings);\n                        if (!module) resolve(true);\n                    } else {\n                        reject('No way to load scripts.');\n                    }\n                });\n            }\n\n            /**\n             * @param {string} wasm\n             * @param {string} module\n             * @returns {Promise.<boolean>}\n             */\n            importWasm(wasm, module = 'Module') {\n                if (typeof Nimiq !== 'undefined' && Nimiq._path) wasm = `${Nimiq._path}${wasm}`;\n                if (typeof __dirname === 'string' && wasm.indexOf('/') === -1) wasm = `${__dirname}/${wasm}`;\n                if (!IWorker._global.WebAssembly) {\n                    Log.w(IWorker, 'No support for WebAssembly available.');\n                    return Promise.resolve(false);\n                }\n\n                return new Promise((resolve) => {\n                    try {\n                        if (PlatformUtils.isNodeJs()) {\n                            const toUint8Array = function (buf) {\n                                const u = new Uint8Array(buf.length);\n                                for (let i = 0; i < buf.length; ++i) {\n                                    u[i] = buf[i];\n                                }\n                                return u;\n                            };\n                            const fs = require('fs');\n                            fs.readFile(wasm, (err, data) => {\n                                if (err) {\n                                    Log.w(IWorker, `Failed to access WebAssembly module ${wasm}: ${err}`);\n                                    resolve(false);\n                                } else {\n                                    IWorker._global[module] = IWorker._global[module] || {};\n                                    IWorker._global[module].wasmBinary = toUint8Array(data);\n                                    resolve(true);\n                                }\n                            });\n                        } else {\n                            const xhr = new XMLHttpRequest();\n                            xhr.open('GET', wasm, true);\n                            xhr.responseType = 'arraybuffer';\n                            xhr.onload = function () {\n                                IWorker._global[module] = IWorker._global[module] || {};\n                                IWorker._global[module].wasmBinary = xhr.response;\n                                resolve(true);\n                            };\n                            xhr.onerror = function () {\n                                Log.w(IWorker, `Failed to access WebAssembly module ${wasm}`);\n                                resolve(false);\n                            };\n                            xhr.send(null);\n                        }\n                    } catch (e) {\n                        Log.w(IWorker, `Failed to access WebAssembly module ${wasm}`);\n                        resolve(false);\n                    }\n                });\n            }\n\n            init(name) {\n                this._name = name;\n                if (IWorker._insideWebWorker) {\n                    self.name = name;\n                    self.onmessage = (msg) => this._onmessage(msg);\n                }\n            }\n\n            _invoke(command, args) {\n                return this[command].apply(this, args);\n            }\n\n            destroy() {\n                if (IWorker._insideWebWorker) {\n                    self.close();\n                }\n            }\n        };\n        for (const funcName of Object.getOwnPropertyNames(clazz.prototype)) {\n            if (typeof clazz.prototype[funcName] === 'function' && funcName !== 'constructor') {\n                Stub.prototype[funcName] = function () {\n                    throw `Not implemented in IWorker Stub: ${funcName}`;\n                };\n            }\n        }\n        return Stub;\n    }\n\n    static Pool(clazz) {\n        const poolClass = class extends clazz {\n            /**\n             *\n             * @param {function(string):Promise} proxyInitializer\n             * @param {string} [name]\n             * @param {number} [size] Number of workers in this pool.\n             */\n            constructor(proxyInitializer, name = 'pool', size = 1) {\n                super();\n                /** @type {function(string):Promise} */\n                this._proxyInitializer = proxyInitializer;\n                /** @type {string} */\n                this._name = name;\n                /** @type {number} */\n                this._poolSize = size;\n                /** @type {Array} */\n                this._workers = [];\n                /** @type {Array} */\n                this._freeWorkers = [];\n                /** @type {Array.<{name:string, args:Array, resolve:function, error:function}>} */\n                this._waitingCalls = [];\n            }\n\n            async start() {\n                await this._updateToSize();\n\n                return this;\n            }\n\n            get poolSize() {\n                return this._poolSize;\n            }\n\n            set poolSize(_size) {\n                this._poolSize = _size;\n                this._updateToSize().catch(Log.w.tag(IWorker));\n            }\n\n            destroy() {\n                this._poolSize = 0;\n                return this._updateToSize();\n            }\n\n            /**\n             * @param {string} name Name of the function to call on a worker\n             * @param {Array} args Arguments to pass to the function\n             * @returns {Promise}\n             */\n            _invoke(name, args) {\n                if (IWorker._workersSupported) {\n                    return new Promise((resolve, error) => {\n                        this._waitingCalls.push({name, args, resolve, error});\n                        const worker = this._freeWorkers.shift();\n                        if (worker) {\n                            this._step(worker).catch(Log.w.tag(IWorker));\n                        }\n                    });\n                } else {\n                    return this._workers[0][name].apply(this._workers[0], args);\n                }\n            }\n\n            /**\n             * @param worker\n             * @returns {Promise.<void>}\n             * @private\n             */\n            async _step(worker) {\n                let call = this._waitingCalls.shift();\n                while (call) {\n                    try {\n                        // eslint-disable-next-line no-await-in-loop\n                        call.resolve(await worker[call.name].apply(worker, call.args));\n                    } catch (e) {\n                        call.error(e);\n                    }\n                    if (this._workers.indexOf(worker) === -1) {\n                        worker.destroy();\n                        return;\n                    }\n                    call = this._waitingCalls.shift();\n                }\n                this._freeWorkers.push(worker);\n            }\n\n            async _updateToSize() {\n                if (typeof Worker === 'undefined' && this._poolSize > 1) {\n                    Log.d(IWorker, 'Pool of size larger than 1 requires WebWorker support.');\n                    this._poolSize = 1;\n                }\n\n                const workerPromises = [];\n                while (this._workers.length + workerPromises.length < this._poolSize) {\n                    workerPromises.push(this._proxyInitializer(`${this._name}#${this._workers.length + workerPromises.length}`));\n                }\n                const createdWorkers = await Promise.all(workerPromises);\n                for (const worker of createdWorkers) {\n                    this._workers.push(worker);\n                    this._step(worker).catch(Log.w.tag(IWorker));\n                }\n\n                while (this._workers.length > this._poolSize) {\n                    const worker = this._freeWorkers.shift() || this._workers.pop();\n                    const idx = this._workers.indexOf(worker);\n                    if (idx >= 0) {\n                        // This was a free worker, also remove it from the worker list and destroy it now.\n                        this._workers.splice(idx, 1);\n                        worker.destroy();\n                    }\n                }\n                return this;\n            }\n        };\n        for (const funcName of Object.getOwnPropertyNames(clazz.prototype)) {\n            if (typeof clazz.prototype[funcName] === 'function' && funcName !== 'constructor') {\n                poolClass.prototype[funcName] = function (...args) {\n                    return this._invoke(funcName, args);\n                };\n            }\n        }\n        return poolClass;\n    }\n}\n\nIWorker._moduleLoadedCallbacks = {};\nIWorker._workerImplementation = {};\nClass.register(IWorker);\n","class Crypto {\n    static get lib() { return CryptoLib.instance; }\n\n    /**\n     * @returns {Promise.<CryptoWorkerImpl>}\n     */\n    static async prepareSyncCryptoWorker() {\n        const impl = IWorker._workerImplementation[CryptoWorker.name];\n        await impl.init('crypto');\n        Crypto._workerSync = impl;\n        return impl;\n    }\n\n    /**\n     * @returns {CryptoWorkerImpl}\n     * @private\n     */\n    static _cryptoWorkerSync() {\n        if (Crypto._workerSync === null) throw new Error('Synchronous crypto worker not yet prepared');\n        return Crypto._workerSync;\n    }\n\n    /**\n     * @returns {Promise.<CryptoWorker>}\n     * @private\n     */\n    static async _cryptoWorkerAsync() {\n        if (!Crypto._workerAsync) {\n            Crypto._workerAsync = await IWorker.startWorkerPoolForProxy(CryptoWorker, 'crypto', 4);\n        }\n        return Crypto._workerAsync;\n    }\n\n\n    /* Public Key */\n\n    static get publicKeyType() {\n        return Uint8Array;\n    }\n\n    static get publicKeySize() {\n        return 32;\n    }\n\n    static publicKeySerialize(key) {\n        // key is already a Uint8Array\n        return key;\n    }\n\n    static publicKeyUnserialize(key) {\n        return key;\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @returns {Uint8Array}\n     */\n    static publicKeyDerive(privateKey) {\n        const worker = Crypto._cryptoWorkerSync();\n        return worker.publicKeyDerive(privateKey);\n    }\n\n\n    /* Private Key */\n\n    static get privateKeyType() {\n        return Uint8Array;\n    }\n\n    static get privateKeySize() {\n        return 32;\n    }\n\n    static privateKeySerialize(key) {\n        // already a Uint8Array\n        return key;\n    }\n\n    static privateKeyUnserialize(key) {\n        return key;\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    static privateKeyGenerate() {\n        const privateKey = new Uint8Array(Crypto.privateKeySize);\n        Crypto.lib.getRandomValues(privateKey);\n        return privateKey;\n    }\n\n\n    /* Key Pair */\n\n    static get keyPairType() {\n        return Object;\n    }\n\n    /**\n     * @returns {{privateKey: Uint8Array, publicKey: Uint8Array}}\n     */\n    static keyPairGenerate() {\n        return Crypto.keyPairDerive(Crypto.privateKeyGenerate());\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @returns {{privateKey: Uint8Array, publicKey: Uint8Array}}\n     */\n    static keyPairDerive(privateKey) {\n        return {\n            privateKey,\n            publicKey: Crypto.publicKeyDerive(privateKey)\n        };\n    }\n\n    static keyPairPrivate(obj) {\n        return obj.privateKey;\n    }\n\n    static keyPairPublic(obj) {\n        return obj.publicKey;\n    }\n\n    static keyPairFromKeys(privateKey, publicKey) {\n        return { privateKey, publicKey };\n    }\n\n\n    /* Simple Signature */\n\n    static get signatureType() {\n        return Uint8Array;\n    }\n\n    static get signatureSize() {\n        return 64;\n    }\n\n    static signatureSerialize(obj) {\n        return obj;\n    }\n\n    static signatureUnserialize(arr) {\n        return arr;\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} data\n     * @returns {Uint8Array}\n     */\n    static signatureCreate(privateKey, publicKey, data) {\n        const worker = Crypto._cryptoWorkerSync();\n        return worker.signatureCreate(privateKey, publicKey, data);\n    }\n\n    /**\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} data\n     * @param {Uint8Array} signature\n     * @returns {boolean}\n     */\n    static signatureVerify(publicKey, data, signature) {\n        const worker = Crypto._cryptoWorkerSync();\n        return worker.signatureVerify(publicKey, data, signature);\n    }\n\n    /**\n     * @param {Uint8Array} block\n     * @param {Array.<bool>} transactionValid\n     * @param {number} timeNow\n     * @returns {Promise.<{valid: boolean, pow: SerialBuffer, interlinkHash: SerialBuffer, bodyHash: SerialBuffer}>}\n     */\n    static async blockVerify(block, transactionValid, timeNow) {\n        const worker = await Crypto._cryptoWorkerAsync();\n        return worker.blockVerify(block, transactionValid, timeNow, Block.GENESIS.HASH.serialize());\n    }\n\n\n    /* Hash Functions */\n\n    static get hashType() {\n        return Uint8Array;\n    }\n\n    /**\n     * @deprecated\n     */\n    static get hashSize() {\n        return 32;\n    }\n\n    static get blake2bSize() {\n        return 32;\n    }\n\n    /**\n     * @param {Uint8Array} data\n     * @returns {Uint8Array}\n     */\n    static blake2bSync(data) {\n        const worker = Crypto._cryptoWorkerSync();\n        return worker.computeBlake2b(data);\n    }\n\n    /**\n     * @param {Uint8Array} data\n     * @returns {Promise.<Uint8Array>}\n     */\n    static async blake2bAsync(data) {\n        const worker = await Crypto._cryptoWorkerAsync();\n        return worker.computeBlake2b(data);\n    }\n\n    static get argon2dSize() {\n        return 32;\n    }\n\n    /**\n     * @param {Uint8Array} data\n     * @returns {Promise.<Uint8Array>}\n     */\n    static async argon2d(data) {\n        const worker = await Crypto._cryptoWorkerAsync();\n        return worker.computeArgon2d(data);\n    }\n\n    static get sha256Size() {\n        return 32;\n    }\n\n    /**\n     * @param {Uint8Array} data\n     * @returns {Uint8Array}\n     */\n    static sha256(data) {\n        const worker = Crypto._cryptoWorkerSync();\n        return worker.computeSha256(data);\n    }\n\n\n    /* Multi Signature */\n\n    static get randomnessSize() {\n        return 32;\n    }\n\n    static get commitmentPairType() {\n        return Object;\n    }\n\n    /**\n     * @returns {{commitment: Uint8Array, secret: Uint8Array}}\n     */\n    static commitmentPairGenerate() {\n        const randomness = new Uint8Array(Crypto.randomnessSize);\n        Crypto.lib.getRandomValues(randomness);\n        const worker = Crypto._cryptoWorkerSync();\n        return worker.commitmentCreate(randomness);\n    }\n\n    static commitmentPairFromValues(secret, commitment) {\n        return { secret, commitment };\n    }\n\n    static commitmentPairRandomSecret(obj) {\n        return obj.secret;\n    }\n\n    static commitmentPairCommitment(obj) {\n        return obj.commitment;\n    }\n\n    static get randomSecretType() {\n        return Uint8Array;\n    }\n\n    static get randomSecretSize() {\n        return 32;\n    }\n\n    static randomSecretSerialize(key) {\n        // secret is already a Uint8Array\n        return key;\n    }\n\n    static randomSecretUnserialize(key) {\n        return key;\n    }\n\n    static get commitmentType() {\n        return Uint8Array;\n    }\n\n    static get commitmentSize() {\n        return 32;\n    }\n\n    static commitmentSerialize(key) {\n        // commitment is already a Uint8Array\n        return key;\n    }\n\n    static commitmentUnserialize(key) {\n        return key;\n    }\n\n    static get partialSignatureType() {\n        return Uint8Array;\n    }\n\n    static get partialSignatureSize() {\n        return 32;\n    }\n\n    static partialSignatureSerialize(obj) {\n        return obj;\n    }\n\n    static partialSignatureUnserialize(arr) {\n        return arr;\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @returns {Uint8Array}\n     */\n    static hashPublicKeys(publicKeys) {\n        const worker = Crypto._cryptoWorkerSync();\n        return worker.publicKeysHash(publicKeys);\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @param {Uint8Array} publicKey\n     * @returns {Uint8Array}\n     */\n    static delinearizePublicKey(publicKeys, publicKey) {\n        const worker = Crypto._cryptoWorkerSync();\n        const publicKeysHash = worker.publicKeysHash(publicKeys);\n        return worker.publicKeyDelinearize(publicKey, publicKeysHash);\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} privateKey\n     * @returns {Uint8Array}\n     */\n    static delinearizePrivateKey(publicKeys, publicKey, privateKey) {\n        const worker = Crypto._cryptoWorkerSync();\n        const publicKeysHash = worker.publicKeysHash(publicKeys);\n        return worker.privateKeyDelinearize(privateKey, publicKey, publicKeysHash);\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @returns {Uint8Array}\n     */\n    static delinearizeAndAggregatePublicKeys(publicKeys) {\n        const worker = Crypto._cryptoWorkerSync();\n        const publicKeysHash = worker.publicKeysHash(publicKeys);\n        return worker.publicKeysDelinearizeAndAggregate(publicKeys, publicKeysHash);\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Array.<Uint8Array>} publicKeys\n     * @param {Uint8Array} secret\n     * @param {Uint8Array} combinedCommitment\n     * @param {Uint8Array} data\n     * @returns {Uint8Array}\n     */\n    static delinearizedPartialSignatureCreate(privateKey, publicKey, publicKeys, secret, combinedCommitment, data) {\n        const worker = Crypto._cryptoWorkerSync();\n        return worker.delinearizedPartialSignatureCreate(publicKeys, privateKey, publicKey, secret, combinedCommitment, data);\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} commitments\n     * @returns {Uint8Array}\n     */\n    static aggregateCommitments(commitments) {\n        const worker = Crypto._cryptoWorkerSync();\n        return worker.commitmentsAggregate(commitments);\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} partialSignatures\n     * @returns {Uint8Array}\n     */\n    static aggregatePartialSignatures(partialSignatures) {\n        const worker = Crypto._cryptoWorkerSync();\n        return partialSignatures.reduce((sigA, sigB) => worker.scalarsAdd(sigA, sigB));\n    }\n\n    /**\n     * @param {Uint8Array} combinedCommitment\n     * @param {Array.<Uint8Array>} partialSignatures\n     * @returns {Uint8Array}\n     */\n    static combinePartialSignatures(combinedCommitment, partialSignatures) {\n        const combinedSignature = Crypto.aggregatePartialSignatures(partialSignatures);\n        return BufferUtils.concatTypedArrays(combinedCommitment, combinedSignature);\n    }\n\n\n    /* Utils */\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @returns {Promise.<Uint8Array>}\n     */\n    static async kdf(key, salt, iterations = 256) {\n        const worker = await Crypto._cryptoWorkerAsync();\n        return worker.kdf(key, salt, iterations);\n    }\n\n    /**\n     * @param {Array.<BlockHeader>} headers\n     * @return {Promise.<void>}\n     */\n    static async manyPow(headers) {\n        const worker = await Crypto._cryptoWorkerAsync();\n        const size = worker.poolSize || 1;\n        const partitions = [];\n        let j = 0;\n        for (let i = 0; i < size; ++i) {\n            partitions.push([]);\n            for (; j < ((i + 1) / size) * headers.length; ++j) {\n                partitions[i].push(headers[j].serialize());\n            }\n        }\n        const promises = [];\n        for (const part of partitions) {\n            promises.push(worker.computeArgon2dBatch(part));\n        }\n        const pows = (await Promise.all(promises)).reduce((a, b) => [...a, ...b], []);\n        for(let i = 0; i < headers.length; ++i) {\n            headers[i]._pow = new Hash(pows[i]);\n        }\n    }\n}\n\n/** @type {CryptoWorkerImpl} */\nCrypto._workerSync = null;\n/** @type {CryptoWorker} */\nCrypto._workerAsync = null;\n\nClass.register(Crypto);\n","/**\n * @interface\n */\nclass CryptoWorker {\n    /**\n     * @param {Uint8Array} input\n     * @returns {Promise.<Uint8Array>}\n     */\n    async computeBlake2b(input) {}\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Promise.<Uint8Array>}\n     */\n    async computeArgon2d(input) {}\n\n    /**\n     * @param {Array.<Uint8Array>} inputs\n     * @returns {Promise.<Array.<Uint8Array>>}\n     */\n    async computeArgon2dBatch(inputs) {}\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Promise.<Uint8Array>}\n     */\n    async computeSha256(input) {}\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @returns {Promise.<Uint8Array>}\n     */\n    async kdf(key, salt, iterations) {}\n\n    /**\n     * @param privateKey\n     * @returns {Promise.<Uint8Array>}\n     */\n    async publicKeyDerive(privateKey) {}\n\n    /**\n     * @param {Uint8Array} randomness\n     * @returns {Promise.<{commitment:Uint8Array, secret:Uint8Array}>}\n     */\n    async commitmentCreate(randomness) {}\n\n    /**\n     * @param {Uint8Array} a\n     * @param {Uint8Array} b\n     * @returns {Promise.<Uint8Array>}\n     */\n    async scalarsAdd(a, b) {}\n\n    /**\n     * @param {Array.<Uint8Array>} commitments\n     * @returns {Promise.<Uint8Array>}\n     */\n    async commitmentsAggregate(commitments) {}\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @returns {Promise.<Uint8Array>}\n     */\n    async publicKeysHash(publicKeys) {}\n\n    /**\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Promise.<Uint8Array>}\n     */\n    async publicKeyDelinearize(publicKey, publicKeysHash) {}\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Promise.<Uint8Array>}\n     */\n    async publicKeysDelinearizeAndAggregate(publicKeys, publicKeysHash) {}\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Promise.<Uint8Array>}\n     */\n    async privateKeyDelinearize(privateKey, publicKey, publicKeysHash) {}\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} secret\n     * @param {Uint8Array} aggregateCommitment\n     * @param {Uint8Array} message\n     * @returns {Promise.<Uint8Array>}\n     */\n    async delinearizedPartialSignatureCreate(publicKeys, privateKey, publicKey, secret, aggregateCommitment, message) {}\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} message\n     * @returns {Promise.<Uint8Array>}\n     */\n    async signatureCreate(privateKey, publicKey, message) {}\n\n    /**\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} message\n     * @param {Uint8Array} signature\n     * @returns {Promise.<bool>}\n     */\n    async signatureVerify(publicKey, message, signature) {}\n\n    /**\n     * @param {Uint8Array} block\n     * @param {Array.<bool>} transactionValid\n     * @param {number} timeNow\n     * @param {Uint8Array} genesisHash\n     * @returns {Promise.<{valid: boolean, pow: SerialBuffer, interlinkHash: SerialBuffer, bodyHash: SerialBuffer}>}\n     */\n    async blockVerify(block, transactionValid, timeNow, genesisHash) {}\n}\nCryptoWorker.ARGON2_HASH_SIZE = 32;\nCryptoWorker.BLAKE2_HASH_SIZE = 32;\nCryptoWorker.SHA256_HASH_SIZE = 32;\nCryptoWorker.PUBLIC_KEY_SIZE = 32;\nCryptoWorker.PRIVATE_KEY_SIZE = 32;\nCryptoWorker.MULTISIG_RANDOMNESS_SIZE = 32;\nCryptoWorker.SIGNATURE_SIZE = 64;\nCryptoWorker.PARTIAL_SIGNATURE_SIZE = 32;\nCryptoWorker.SIGNATURE_HASH_SIZE = 64;\nClass.register(CryptoWorker);\n","class CryptoWorkerImpl extends IWorker.Stub(CryptoWorker) {\n    constructor() {\n        super();\n        // FIXME: This is needed for Babel to work correctly. Can be removed as soon as we updated to Babel v7.\n        this._superInit = super.init;\n    }\n\n    async init(name) {\n        if (IWorker._insideWebWorker) {\n            Crypto._workerSync = this;\n            Crypto._workerAsync = this;\n        }\n        await this._superInit.call(this, name);\n\n        if (await this.importWasm('worker-wasm.wasm')) {\n            await this.importScript('worker-wasm.js');\n        } else {\n            await this.importScript('worker-js.js');\n        }\n\n        const memoryStart = Module._get_static_memory_start();\n        const memorySize = Module._get_static_memory_size();\n        if (memorySize < CryptoWorker.PUBLIC_KEY_SIZE + CryptoWorker.PRIVATE_KEY_SIZE + CryptoWorker.SIGNATURE_SIZE) {\n            throw Error('Static memory too small');\n        }\n        let byteOffset = memoryStart;\n        this._pubKeyPointer = byteOffset;\n        this._pubKeyBuffer = new Uint8Array(Module.HEAP8.buffer, byteOffset, CryptoWorker.PUBLIC_KEY_SIZE);\n        byteOffset += CryptoWorker.PUBLIC_KEY_SIZE;\n        this._privKeyPointer = byteOffset;\n        this._privKeyBuffer = new Uint8Array(Module.HEAP8.buffer, byteOffset, CryptoWorker.PRIVATE_KEY_SIZE);\n        byteOffset += CryptoWorker.PRIVATE_KEY_SIZE;\n        this._signaturePointer = byteOffset;\n        this._signatureBuffer = new Uint8Array(Module.HEAP8.buffer, byteOffset, CryptoWorker.SIGNATURE_SIZE);\n        byteOffset += CryptoWorker.SIGNATURE_SIZE;\n        this._messagePointer = byteOffset;\n        this._messageBuffer = new Uint8Array(Module.HEAP8.buffer, byteOffset, (memoryStart + memorySize) - byteOffset);\n    }\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Uint8Array}\n     */\n    computeBlake2b(input) {\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOut = Module.stackAlloc(CryptoWorker.BLAKE2_HASH_SIZE);\n            const wasmIn = Module.stackAlloc(input.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n            const res = Module._nimiq_blake2(wasmOut, wasmIn, input.length);\n            if (res !== 0) {\n                throw res;\n            }\n            const hash = new Uint8Array(CryptoWorker.BLAKE2_HASH_SIZE);\n            hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, CryptoWorker.BLAKE2_HASH_SIZE));\n            return hash;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Uint8Array}\n     */\n    computeArgon2d(input) {\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOut = Module.stackAlloc(CryptoWorker.ARGON2_HASH_SIZE);\n            const wasmIn = Module.stackAlloc(input.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n            const res = Module._nimiq_argon2(wasmOut, wasmIn, input.length, 512);\n            if (res !== 0) {\n                throw res;\n            }\n            const hash = new Uint8Array(CryptoWorker.ARGON2_HASH_SIZE);\n            hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, CryptoWorker.ARGON2_HASH_SIZE));\n            return hash;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} inputs\n     * @returns {Array.<Uint8Array>}\n     */\n    computeArgon2dBatch(inputs) {\n        const hashes = [];\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOut = Module.stackAlloc(CryptoWorker.ARGON2_HASH_SIZE);\n            const stackTmp = Module.stackSave();\n            for(const input of inputs) {\n                Module.stackRestore(stackTmp);\n                const wasmIn = Module.stackAlloc(input.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n                const res = Module._nimiq_argon2(wasmOut, wasmIn, input.length, 512);\n                if (res !== 0) {\n                    throw res;\n                }\n                const hash = new Uint8Array(CryptoWorker.ARGON2_HASH_SIZE);\n                hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, CryptoWorker.ARGON2_HASH_SIZE));\n                hashes.push(hash);\n            }\n            return hashes;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Uint8Array}\n     */\n    computeSha256(input) {\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOut = Module.stackAlloc(CryptoWorker.SHA256_HASH_SIZE);\n            const wasmIn = Module.stackAlloc(input.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n            Module._nimiq_sha256(wasmOut, wasmIn, input.length);\n            const hash = new Uint8Array(CryptoWorker.SHA256_HASH_SIZE);\n            hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, CryptoWorker.SHA256_HASH_SIZE));\n            return hash;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @returns {Uint8Array}\n     */\n    kdf(key, salt, iterations) {\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOut = Module.stackAlloc(CryptoWorker.ARGON2_HASH_SIZE);\n            const wasmIn = Module.stackAlloc(key.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmIn, key.length).set(key);\n            const wasmSalt = Module.stackAlloc(salt.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmSalt, salt.length).set(salt);\n            const res = Module._nimiq_kdf(wasmOut, wasmIn, key.length, wasmSalt, salt.length, 512, iterations);\n            if (res !== 0) {\n                throw res;\n            }\n            const hash = new Uint8Array(CryptoWorker.ARGON2_HASH_SIZE);\n            hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, CryptoWorker.ARGON2_HASH_SIZE));\n            return hash;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @returns {Uint8Array}\n     */\n    publicKeyDerive(privateKey) {\n        const publicKey = new Uint8Array(CryptoWorker.PUBLIC_KEY_SIZE);\n        if (privateKey.byteLength !== CryptoWorker.PRIVATE_KEY_SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        this._privKeyBuffer.set(privateKey);\n        Module._ed25519_public_key_derive(this._pubKeyPointer, this._privKeyPointer);\n        this._privKeyBuffer.fill(0);\n        publicKey.set(this._pubKeyBuffer);\n        return publicKey;\n    }\n\n    /**\n     * @param {Uint8Array} randomness\n     * @returns {{commitment:Uint8Array, secret:Uint8Array}}\n     */\n    commitmentCreate(randomness) {\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOutCommitment = Module.stackAlloc(CryptoWorker.PUBLIC_KEY_SIZE);\n            const wasmOutSecret = Module.stackAlloc(CryptoWorker.PRIVATE_KEY_SIZE);\n            const wasmIn = Module.stackAlloc(randomness.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmIn, randomness.length).set(randomness);\n            const res = Module._ed25519_create_commitment(wasmOutSecret, wasmOutCommitment, wasmIn);\n            if (res !== 1) {\n                throw new Error(`Secret must not be 0 or 1: ${res}`);\n            }\n            const commitment = new Uint8Array(CryptoWorker.PUBLIC_KEY_SIZE);\n            const secret = new Uint8Array(CryptoWorker.PRIVATE_KEY_SIZE);\n            commitment.set(new Uint8Array(Module.HEAPU8.buffer, wasmOutCommitment, CryptoWorker.PUBLIC_KEY_SIZE));\n            secret.set(new Uint8Array(Module.HEAPU8.buffer, wasmOutSecret, CryptoWorker.PRIVATE_KEY_SIZE));\n            return {commitment, secret};\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Uint8Array} a\n     * @param {Uint8Array} b\n     * @returns {Uint8Array}\n     */\n    scalarsAdd(a, b) {\n        if (a.byteLength !== CryptoWorker.PARTIAL_SIGNATURE_SIZE || b.byteLength !== CryptoWorker.PARTIAL_SIGNATURE_SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOutSum = Module.stackAlloc(CryptoWorker.PARTIAL_SIGNATURE_SIZE);\n            const wasmInA = Module.stackAlloc(a.length);\n            const wasmInB = Module.stackAlloc(b.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInA, a.length).set(a);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInB, b.length).set(b);\n            Module._ed25519_add_scalars(wasmOutSum, wasmInA, wasmInB);\n            const sum = new Uint8Array(CryptoWorker.PARTIAL_SIGNATURE_SIZE);\n            sum.set(new Uint8Array(Module.HEAPU8.buffer, wasmOutSum, CryptoWorker.PARTIAL_SIGNATURE_SIZE));\n            return sum;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} commitments\n     * @returns {Uint8Array}\n     */\n    commitmentsAggregate(commitments) {\n        if (commitments.some(commitment => commitment.byteLength !== CryptoWorker.PUBLIC_KEY_SIZE)) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedCommitments = new Uint8Array(commitments.length * CryptoWorker.PUBLIC_KEY_SIZE);\n        for (let i = 0; i < commitments.length; ++i) {\n            concatenatedCommitments.set(commitments[i], i * CryptoWorker.PUBLIC_KEY_SIZE);\n        }\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOut = Module.stackAlloc(CryptoWorker.PUBLIC_KEY_SIZE);\n            const wasmInCommitments = Module.stackAlloc(concatenatedCommitments.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInCommitments, concatenatedCommitments.length).set(concatenatedCommitments);\n            Module._ed25519_aggregate_commitments(wasmOut, wasmInCommitments, commitments.length);\n            const aggCommitments = new Uint8Array(CryptoWorker.PUBLIC_KEY_SIZE);\n            aggCommitments.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, CryptoWorker.PUBLIC_KEY_SIZE));\n            return aggCommitments;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @returns {Uint8Array}\n     */\n    publicKeysHash(publicKeys) {\n        if (publicKeys.some(publicKey => publicKey.byteLength !== CryptoWorker.PUBLIC_KEY_SIZE)) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedPublicKeys = new Uint8Array(publicKeys.length * CryptoWorker.PUBLIC_KEY_SIZE);\n        for (let i = 0; i < publicKeys.length; ++i) {\n            concatenatedPublicKeys.set(publicKeys[i], i * CryptoWorker.PUBLIC_KEY_SIZE);\n        }\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOut = Module.stackAlloc(CryptoWorker.SIGNATURE_HASH_SIZE);\n            const wasmInPublicKeys = Module.stackAlloc(concatenatedPublicKeys.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeys, concatenatedPublicKeys.length).set(concatenatedPublicKeys);\n            Module._ed25519_hash_public_keys(wasmOut, wasmInPublicKeys, publicKeys.length);\n            const hashedPublicKey = new Uint8Array(CryptoWorker.SIGNATURE_HASH_SIZE);\n            hashedPublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, CryptoWorker.SIGNATURE_HASH_SIZE));\n            return hashedPublicKey;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Uint8Array}\n     */\n    publicKeyDelinearize(publicKey, publicKeysHash) {\n        if (publicKey.byteLength !== CryptoWorker.PUBLIC_KEY_SIZE\n            || publicKeysHash.byteLength !== CryptoWorker.SIGNATURE_HASH_SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOut = Module.stackAlloc(CryptoWorker.PUBLIC_KEY_SIZE);\n            const wasmInPublicKey = Module.stackAlloc(publicKey.length);\n            const wasmInPublicKeysHash = Module.stackAlloc(publicKeysHash.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKey, publicKey.length).set(publicKey);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeysHash, publicKeysHash.length).set(publicKeysHash);\n            Module._ed25519_delinearize_public_key(wasmOut, wasmInPublicKeysHash, wasmInPublicKey);\n            const delinearizedPublicKey = new Uint8Array(CryptoWorker.PUBLIC_KEY_SIZE);\n            delinearizedPublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, CryptoWorker.PUBLIC_KEY_SIZE));\n            return delinearizedPublicKey;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Uint8Array}\n     */\n    publicKeysDelinearizeAndAggregate(publicKeys, publicKeysHash) {\n        if (publicKeys.some(publicKey => publicKey.byteLength !== CryptoWorker.PUBLIC_KEY_SIZE)\n            || publicKeysHash.byteLength !== CryptoWorker.SIGNATURE_HASH_SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedPublicKeys = new Uint8Array(publicKeys.length * CryptoWorker.PUBLIC_KEY_SIZE);\n        for (let i = 0; i < publicKeys.length; ++i) {\n            concatenatedPublicKeys.set(publicKeys[i], i * CryptoWorker.PUBLIC_KEY_SIZE);\n        }\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOut = Module.stackAlloc(CryptoWorker.PUBLIC_KEY_SIZE);\n            const wasmInPublicKeys = Module.stackAlloc(concatenatedPublicKeys.length);\n            const wasmInPublicKeysHash = Module.stackAlloc(publicKeysHash.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeys, concatenatedPublicKeys.length).set(concatenatedPublicKeys);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeysHash, publicKeysHash.length).set(publicKeysHash);\n            Module._ed25519_aggregate_delinearized_public_keys(wasmOut, wasmInPublicKeysHash, wasmInPublicKeys, publicKeys.length);\n            const aggregatePublicKey = new Uint8Array(CryptoWorker.PUBLIC_KEY_SIZE);\n            aggregatePublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, CryptoWorker.PUBLIC_KEY_SIZE));\n            return aggregatePublicKey;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Uint8Array}\n     */\n    privateKeyDelinearize(privateKey, publicKey, publicKeysHash) {\n        if (privateKey.byteLength !== CryptoWorker.PRIVATE_KEY_SIZE\n            || publicKey.byteLength !== CryptoWorker.PUBLIC_KEY_SIZE\n            || publicKeysHash.byteLength !== CryptoWorker.SIGNATURE_HASH_SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOut = Module.stackAlloc(CryptoWorker.PUBLIC_KEY_SIZE);\n            const wasmInPrivateKey = Module.stackAlloc(privateKey.length);\n            const wasmInPublicKey = Module.stackAlloc(publicKey.length);\n            const wasmInPublicKeysHash = Module.stackAlloc(publicKeysHash.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInPrivateKey, privateKey.length).set(privateKey);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKey, publicKey.length).set(publicKey);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeysHash, publicKeysHash.length).set(publicKeysHash);\n            Module._ed25519_derive_delinearized_private_key(wasmOut, wasmInPublicKeysHash, wasmInPublicKey, wasmInPrivateKey);\n            const delinearizedPrivateKey = new Uint8Array(CryptoWorker.PRIVATE_KEY_SIZE);\n            delinearizedPrivateKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, CryptoWorker.PRIVATE_KEY_SIZE));\n            return delinearizedPrivateKey;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} secret\n     * @param {Uint8Array} aggregateCommitment\n     * @param {Uint8Array} message\n     * @returns {Uint8Array}\n     */\n    delinearizedPartialSignatureCreate(publicKeys, privateKey, publicKey, secret, aggregateCommitment, message) {\n        if (publicKeys.some(publicKey => publicKey.byteLength !== CryptoWorker.PUBLIC_KEY_SIZE)\n            || privateKey.byteLength !== CryptoWorker.PRIVATE_KEY_SIZE\n            || publicKey.byteLength !== CryptoWorker.PUBLIC_KEY_SIZE\n            || secret.byteLength !== CryptoWorker.PRIVATE_KEY_SIZE\n            || aggregateCommitment.byteLength !== CryptoWorker.PUBLIC_KEY_SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedPublicKeys = new Uint8Array(publicKeys.length * CryptoWorker.PUBLIC_KEY_SIZE);\n        for (let i = 0; i < publicKeys.length; ++i) {\n            concatenatedPublicKeys.set(publicKeys[i], i * CryptoWorker.PUBLIC_KEY_SIZE);\n        }\n        let stackPtr;\n        try {\n            stackPtr = Module.stackSave();\n            const wasmOut = Module.stackAlloc(CryptoWorker.PARTIAL_SIGNATURE_SIZE);\n            const wasmInPublicKeys = Module.stackAlloc(concatenatedPublicKeys.length);\n            const wasmInPrivateKey = Module.stackAlloc(privateKey.length);\n            const wasmInPublicKey = Module.stackAlloc(publicKey.length);\n            const wasmInSecret = Module.stackAlloc(secret.length);\n            const wasmInCommitment = Module.stackAlloc(aggregateCommitment.length);\n            const wasmInMessage = Module.stackAlloc(message.length);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeys, concatenatedPublicKeys.length).set(concatenatedPublicKeys);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInPrivateKey, privateKey.length).set(privateKey);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKey, publicKey.length).set(publicKey);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInSecret, secret.length).set(secret);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInCommitment, aggregateCommitment.length).set(aggregateCommitment);\n            new Uint8Array(Module.HEAPU8.buffer, wasmInMessage, message.length).set(message);\n            Module._ed25519_delinearized_partial_sign(wasmOut, wasmInMessage, message.length, wasmInCommitment, wasmInSecret, wasmInPublicKeys, publicKeys.length, wasmInPublicKey, wasmInPrivateKey);\n            const partialSignature = new Uint8Array(CryptoWorker.PARTIAL_SIGNATURE_SIZE);\n            partialSignature.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, CryptoWorker.PARTIAL_SIGNATURE_SIZE));\n            return partialSignature;\n        } catch (e) {\n            Log.w(CryptoWorkerImpl, e);\n            throw e;\n        } finally {\n            if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n        }\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} message\n     * @returns {Uint8Array}\n     */\n    signatureCreate(privateKey, publicKey, message) {\n        const signature = new Uint8Array(CryptoWorker.SIGNATURE_SIZE);\n        const messageLength = message.byteLength;\n        if (messageLength > this._messageBuffer.byteLength\n            || publicKey.byteLength !== CryptoWorker.PUBLIC_KEY_SIZE\n            || privateKey.byteLength !== CryptoWorker.PRIVATE_KEY_SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        this._messageBuffer.set(message);\n        this._pubKeyBuffer.set(publicKey);\n        this._privKeyBuffer.set(privateKey);\n        Module._ed25519_sign(this._signaturePointer, this._messagePointer, messageLength,\n            this._pubKeyPointer, this._privKeyPointer);\n        this._privKeyBuffer.fill(0);\n        signature.set(this._signatureBuffer);\n        return signature;\n    }\n\n    /**\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} message\n     * @param {Uint8Array} signature\n     * @returns {boolean}\n     */\n    signatureVerify(publicKey, message, signature) {\n        const messageLength = message.byteLength;\n        if (signature.byteLength !== CryptoWorker.SIGNATURE_SIZE\n            || message.byteLength > this._messageBuffer.byteLength\n            || publicKey.byteLength !== CryptoWorker.PUBLIC_KEY_SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        this._signatureBuffer.set(signature);\n        this._messageBuffer.set(message);\n        this._pubKeyBuffer.set(publicKey);\n        return !!Module._ed25519_verify(this._signaturePointer, this._messagePointer, messageLength,\n            this._pubKeyPointer);\n    }\n\n    /**\n     * @param {Uint8Array} blockSerialized\n     * @param {Array.<boolean|undefined>} transactionValid\n     * @param {number} timeNow\n     * @param {Uint8Array} genesisHash\n     * @returns {Promise.<{valid: boolean, pow: SerialBuffer, interlinkHash: SerialBuffer, bodyHash: SerialBuffer}>}\n     */\n    async blockVerify(blockSerialized, transactionValid, timeNow, genesisHash) {\n        // XXX Create a stub genesis block within the worker.\n        if (!Block.GENESIS) {\n            Block.GENESIS = { HASH: Hash.unserialize(new SerialBuffer(genesisHash)) };\n        }\n\n        const block = Block.unserialize(new SerialBuffer(blockSerialized));\n        for (let i = 0; i < transactionValid.length; i++) {\n            block.body.transactions[i]._valid = transactionValid[i];\n        }\n\n        const valid = await block._verify(timeNow);\n        const pow = await block.header.pow();\n        const interlinkHash = block.interlink.hash();\n        const bodyHash = block.body.hash();\n        return { valid: valid, pow: pow.serialize(), interlinkHash: interlinkHash.serialize(), bodyHash: bodyHash.serialize() };\n    }\n}\n\nIWorker.prepareForWorkerUse(CryptoWorker, new CryptoWorkerImpl());\n","class NumberUtils {\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint8(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT8_MAX;\n    }\n\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint16(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT16_MAX;\n    }\n\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint32(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT32_MAX;\n    }\n\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint64(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT64_MAX;\n    }\n\n    /**\n     * @return {number}\n     */\n    static randomUint32() {\n        return Math.floor(Math.random() * (NumberUtils.UINT32_MAX + 1));\n    }\n\n    /**\n     * @return {number}\n     */\n    static randomUint64() {\n        return Math.floor(Math.random() * (NumberUtils.UINT64_MAX + 1));\n    }\n}\n\nNumberUtils.UINT8_MAX = 255;\nNumberUtils.UINT16_MAX = 65535;\nNumberUtils.UINT32_MAX = 4294967295;\nNumberUtils.UINT64_MAX = Number.MAX_SAFE_INTEGER;\n//Object.freeze(NumberUtils);\nClass.register(NumberUtils);\n","class BufferUtils {\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toAscii(buffer) {\n        return String.fromCharCode.apply(null, new Uint8Array(buffer));\n    }\n\n    /**\n     * @param {string} string\n     * @return {Uint8Array}\n     */\n    static fromAscii(string) {\n        const buf = new Uint8Array(string.length);\n        for (let i = 0; i < string.length; ++i) {\n            buf[i] = string.charCodeAt(i);\n        }\n        return buf;\n    }\n\n    static _codePointTextDecoder(u8) {\n        if (typeof TextDecoder === 'undefined') throw new Error('TextDecoder not supported');\n        if (BufferUtils._ISO_8859_15_DECODER === null) throw new Error('TextDecoder does not supprot iso-8859-15');\n        if (BufferUtils._ISO_8859_15_DECODER === undefined) {\n            try {\n                BufferUtils._ISO_8859_15_DECODER = new TextDecoder('iso-8859-15');\n            } finally {\n                BufferUtils._ISO_8859_15_DECODER = null;\n            }\n        }\n        return BufferUtils._ISO_8859_15_DECODER.decode(u8)\n            .replace('', '').replace('', '').replace('', '').replace('', '')\n            .replace('', '').replace('', '').replace('', '').replace('', '');\n    }\n\n    static _tripletToBase64(num) {\n        return BufferUtils._BASE64_LOOKUP[num >> 18 & 0x3F] + BufferUtils._BASE64_LOOKUP[num >> 12 & 0x3F] + BufferUtils._BASE64_LOOKUP[num >> 6 & 0x3F] + BufferUtils._BASE64_LOOKUP[num & 0x3F];\n    }\n\n    static _base64encodeChunk(u8, start, end) {\n        let tmp;\n        const output = [];\n        for (let i = start; i < end; i += 3) {\n            tmp = ((u8[i] << 16) & 0xFF0000) + ((u8[i + 1] << 8) & 0xFF00) + (u8[i + 2] & 0xFF);\n            output.push(BufferUtils._tripletToBase64(tmp));\n        }\n        return output.join('');\n    }\n\n    static _base64fromByteArray(u8) {\n        let tmp;\n        const len = u8.length;\n        const extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n        let output = '';\n        const parts = [];\n        const maxChunkLength = 16383; // must be multiple of 3\n\n        // go through the array every three bytes, we'll deal with trailing stuff later\n        for (let i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n            parts.push(BufferUtils._base64encodeChunk(u8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n        }\n\n        // pad the end with zeros, but make sure to not forget the extra bytes\n        if (extraBytes === 1) {\n            tmp = u8[len - 1];\n            output += BufferUtils._BASE64_LOOKUP[tmp >> 2];\n            output += BufferUtils._BASE64_LOOKUP[(tmp << 4) & 0x3F];\n            output += '==';\n        } else if (extraBytes === 2) {\n            tmp = (u8[len - 2] << 8) + (u8[len - 1]);\n            output += BufferUtils._BASE64_LOOKUP[tmp >> 10];\n            output += BufferUtils._BASE64_LOOKUP[(tmp >> 4) & 0x3F];\n            output += BufferUtils._BASE64_LOOKUP[(tmp << 2) & 0x3F];\n            output += '=';\n        }\n\n        parts.push(output);\n\n        return parts.join('');\n    }\n\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toBase64(buffer) {\n        if (PlatformUtils.isNodeJs()) {\n            return new Buffer(buffer).toString('base64');\n        } else if (typeof TextDecoder !== 'undefined' && BufferUtils._ISO_8859_15_DECODER !== null) {\n            try {\n                return btoa(BufferUtils._codePointTextDecoder(new Uint8Array(buffer)));\n            } catch (e) {\n                // Disabled itself\n            }\n        }\n\n        return BufferUtils._base64fromByteArray(new Uint8Array(buffer));\n    }\n\n    /**\n     * @param {string} base64\n     * @return {SerialBuffer}\n     */\n    static fromBase64(base64) {\n        return new SerialBuffer(Uint8Array.from(atob(base64), c => c.charCodeAt(0)));\n    }\n\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toBase64Url(buffer) {\n        return BufferUtils.toBase64(buffer).replace(/\\//g, '_').replace(/\\+/g, '-').replace(/=/g, '.');\n    }\n\n    /**\n     * @param {string} base64\n     * @return {SerialBuffer}\n     */\n    static fromBase64Url(base64) {\n        return new SerialBuffer(Uint8Array.from(atob(base64.replace(/_/g, '/').replace(/-/g, '+').replace(/\\./g, '=')), c => c.charCodeAt(0)));\n    }\n\n    /**\n     * @param {Uint8Array} buf\n     * @param {string} [alphabet] Alphabet to use\n     * @return {string}\n     */\n    static toBase32(buf, alphabet = BufferUtils.BASE32_ALPHABET.NIMIQ) {\n        let shift = 3, carry = 0, byte, symbol, i, res = '';\n\n        for (i = 0; i < buf.length; i++) {\n            byte = buf[i];\n            symbol = carry | (byte >> shift);\n            res += alphabet[symbol & 0x1f];\n\n            if (shift > 5) {\n                shift -= 5;\n                symbol = byte >> shift;\n                res += alphabet[symbol & 0x1f];\n            }\n\n            shift = 5 - shift;\n            carry = byte << shift;\n            shift = 8 - shift;\n        }\n\n        if (shift !== 3) {\n            res += alphabet[carry & 0x1f];\n        }\n\n        while (res.length % 8 !== 0 && alphabet.length === 33) {\n            res += alphabet[32];\n        }\n\n        return res;\n    }\n\n    /**\n     * @param {string} base32\n     * @param {string} [alphabet] Alphabet to use\n     * @return {Uint8Array}\n     */\n    static fromBase32(base32, alphabet = BufferUtils.BASE32_ALPHABET.NIMIQ) {\n        const charmap = [];\n        alphabet.toUpperCase().split('').forEach((c, i) => {\n            if (!(c in charmap)) charmap[c] = i;\n        });\n\n        let symbol, shift = 8, carry = 0, buf = [];\n        base32.toUpperCase().split('').forEach((char) => {\n            // ignore padding\n            if (alphabet.length === 33 && char === alphabet[32]) return;\n\n            symbol = charmap[char] & 0xff;\n\n            shift -= 5;\n            if (shift > 0) {\n                carry |= symbol << shift;\n            } else if (shift < 0) {\n                buf.push(carry | (symbol >> -shift));\n                shift += 8;\n                carry = (symbol << shift) & 0xff;\n            } else {\n                buf.push(carry | symbol);\n                shift = 8;\n                carry = 0;\n            }\n        });\n\n        if (shift !== 8 && carry !== 0) {\n            buf.push(carry);\n        }\n\n        return new Uint8Array(buf);\n    }\n\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toHex(buffer) {\n        let hex = '';\n        for (let i = 0; i < buffer.length; i++) {\n            const code = buffer[i];\n            hex += BufferUtils.HEX_ALPHABET[code >>> 4];\n            hex += BufferUtils.HEX_ALPHABET[code & 0x0F];\n        }\n        return hex;\n    }\n\n    /**\n     * @param {string} hex\n     * @return {SerialBuffer}\n     */\n    static fromHex(hex) {\n        hex = hex.trim();\n        if (!StringUtils.isHexBytes(hex)) return null;\n        return new SerialBuffer(Uint8Array.from(hex.match(/.{2}/g) || [], byte => parseInt(byte, 16)));\n    }\n\n    /**\n     * @template T\n     * @param {T} a\n     * @param {*} b\n     * @return {T}\n     */\n    static concatTypedArrays(a, b) {\n        const c = new (a.constructor)(a.length + b.length);\n        c.set(a, 0);\n        c.set(b, a.length);\n        return c;\n    }\n\n    /**\n     * @param {*} a\n     * @param {*} b\n     * @return {boolean}\n     */\n    static equals(a, b) {\n        if (a.length !== b.length) return false;\n        const viewA = new Uint8Array(a);\n        const viewB = new Uint8Array(b);\n        for (let i = 0; i < a.length; i++) {\n            if (viewA[i] !== viewB[i]) return false;\n        }\n        return true;\n    }\n\n    /**\n     * @param {*} a\n     * @param {*} b\n     * @return {number} -1 if a is smaller than b, 1 if a is larger than b, 0 if a equals b.\n     */\n    static compare(a, b) {\n        if (a.length < b.length) return -1;\n        if (a.length > b.length) return 1;\n        for (let i = 0; i < a.length; i++) {\n            if (a[i] < b[i]) return -1;\n            if (a[i] > b[i]) return 1;\n        }\n        return 0;\n    }\n\n    /**\n     * @param {Uint8Array} a\n     * @param {Uint8Array} b\n     * @return {Uint8Array}\n     */\n    static xor(a, b) {\n        const res = new Uint8Array(a.byteLength);\n        for (let i = 0; i < a.byteLength; ++i) {\n            res[i] = a[i] ^ b[i];\n        }\n        return res;\n    }\n}\nBufferUtils.BASE64_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nBufferUtils.BASE32_ALPHABET = {\n    RFC4648: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n    RFC4648_HEX: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n    NIMIQ: '0123456789ABCDEFGHJKLMNPQRSTUVXY'\n};\nBufferUtils.HEX_ALPHABET = '0123456789abcdef';\nBufferUtils._BASE64_LOOKUP = [];\nfor (let i = 0, len = BufferUtils.BASE64_ALPHABET.length; i < len; ++i) {\n    BufferUtils._BASE64_LOOKUP[i] = BufferUtils.BASE64_ALPHABET[i];\n}\n\nClass.register(BufferUtils);\n","class SerialBuffer extends Uint8Array {\n    /**\n     * @param {*} bufferOrArrayOrLength\n     */\n    constructor(bufferOrArrayOrLength) {\n        super(bufferOrArrayOrLength);\n        this._view = new DataView(this.buffer);\n        this._readPos = 0;\n        this._writePos = 0;\n    }\n\n    /**\n     * @param {number} start\n     * @param {number} end\n     * @return {Uint8Array}\n     */\n    subarray(start, end) {\n        return ArrayUtils.subarray(this, start, end);\n    }\n\n    /** @type {number} */\n    get readPos() {\n        return this._readPos;\n    }\n\n    /** @type {number} */\n    set readPos(value) {\n        if (value < 0 || value > this.byteLength) throw `Invalid readPos ${value}`;\n        this._readPos = value;\n    }\n\n    /** @type {number} */\n    get writePos() {\n        return this._writePos;\n    }\n\n    /** @type {number} */\n    set writePos(value) {\n        if (value < 0 || value > this.byteLength) throw `Invalid writePos ${value}`;\n        this._writePos = value;\n    }\n\n    /**\n     * Resets the read and write position of the buffer to zero.\n     * @returns {void}\n     */\n    reset() {\n        this._readPos = 0;\n        this._writePos = 0;\n    }\n\n    /**\n     * @param {number} length\n     * @return {Uint8Array}\n     */\n    read(length) {\n        const value = this.subarray(this._readPos, this._readPos + length);\n        this._readPos += length;\n        return value;\n    }\n\n    /**\n     * @param {*} array\n     */\n    write(array) {\n        this.set(array, this._writePos);\n        this._writePos += array.byteLength;\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint8() {\n        return this._view.getUint8(this._readPos++);\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint8(value) {\n        this._view.setUint8(this._writePos++, value);\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint16() {\n        const value = this._view.getUint16(this._readPos);\n        this._readPos += 2;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint16(value) {\n        this._view.setUint16(this._writePos, value);\n        this._writePos += 2;\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint32() {\n        const value = this._view.getUint32(this._readPos);\n        this._readPos += 4;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint32(value) {\n        this._view.setUint32(this._writePos, value);\n        this._writePos += 4;\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint64() {\n        const value = this._view.getUint32(this._readPos) * Math.pow(2, 32) + this._view.getUint32(this._readPos + 4);\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        this._readPos += 8;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint64(value) {\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        this._view.setUint32(this._writePos, Math.floor(value / Math.pow(2, 32)));\n        this._view.setUint32(this._writePos + 4, value);\n        this._writePos += 8;\n    }\n\n    /**\n     * @return {number}\n     */\n    readVarUint() {\n        const value = this.readUint8();\n        if (value < 0xFD) {\n            return value;\n        } else if (value === 0xFD) {\n            return this.readUint16();\n        } else if (value === 0xFE) {\n            return this.readUint32();\n        } else /*if (value === 0xFF)*/ {\n            return this.readUint64();\n        }\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeVarUint(value) {\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        if (value < 0xFD) {\n            this.writeUint8(value);\n        } else if (value <= 0xFFFF) {\n            this.writeUint8(0xFD);\n            this.writeUint16(value);\n        } else if (value <= 0xFFFFFFFF) {\n            this.writeUint8(0xFE);\n            this.writeUint32(value);\n        } else {\n            this.writeUint8(0xFF);\n            this.writeUint64(value);\n        }\n    }\n\n    /**\n     * @param {number} value\n     * @returns {number}\n     */\n    static varUintSize(value) {\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        if (value < 0xFD) {\n            return 1;\n        } else if (value <= 0xFFFF) {\n            return 3;\n        } else if (value <= 0xFFFFFFFF) {\n            return 5;\n        } else {\n            return 9;\n        }\n    }\n\n    /**\n     * @return {number}\n     */\n    readFloat64() {\n        const value = this._view.getFloat64(this._readPos);\n        this._readPos += 8;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeFloat64(value) {\n        this._view.setFloat64(this._writePos, value);\n        this._writePos += 8;\n    }\n\n    /**\n     * @param {number} length\n     * @return {string}\n     */\n    readString(length) {\n        const bytes = this.read(length);\n        return BufferUtils.toAscii(bytes);\n    }\n\n    /**\n     * @param {string} value\n     * @param {number} length\n     */\n    writeString(value, length) {\n        if (StringUtils.isMultibyte(value) || value.length !== length) throw 'Malformed value/length';\n        const bytes = BufferUtils.fromAscii(value);\n        this.write(bytes);\n    }\n\n    /**\n     * @param {number} length\n     * @return {string}\n     */\n    readPaddedString(length) {\n        const bytes = this.read(length);\n        let i = 0;\n        while (i < length && bytes[i] !== 0x0) i++;\n        const view = new Uint8Array(bytes.buffer, bytes.byteOffset, i);\n        return BufferUtils.toAscii(view);\n    }\n\n    /**\n     * @param {string} value\n     * @param {number} length\n     */\n    writePaddedString(value, length) {\n        if (StringUtils.isMultibyte(value) || value.length > length) throw 'Malformed value/length';\n        const bytes = BufferUtils.fromAscii(value);\n        this.write(bytes);\n        const padding = length - bytes.byteLength;\n        this.write(new Uint8Array(padding));\n    }\n\n    /**\n     * @return {string}\n     */\n    readVarLengthString() {\n        const length = this.readUint8();\n        if (this._readPos + length > this.length) throw 'Malformed length';\n        const bytes = this.read(length);\n        return BufferUtils.toAscii(bytes);\n    }\n\n    /**\n     * @param {string} value\n     */\n    writeVarLengthString(value) {\n        if (StringUtils.isMultibyte(value) || !NumberUtils.isUint8(value.length)) throw new Error('Malformed value');\n        const bytes = BufferUtils.fromAscii(value);\n        this.writeUint8(bytes.byteLength);\n        this.write(bytes);\n    }\n\n    /**\n     * @param {string} value\n     * @returns {number}\n     */\n    static varLengthStringSize(value) {\n        if (StringUtils.isMultibyte(value) || !NumberUtils.isUint8(value.length)) throw new Error('Malformed value');\n        return /*length*/ 1 + value.length;\n    }\n}\nClass.register(SerialBuffer);\n","/**\n * @interface\n */\nclass MinerWorker {\n    /**\n     * @param blockHeader\n     * @param compact\n     * @param minNonce\n     * @param maxNonce\n     * @returns {Promise.<{hash: Uint8Array, nonce: number}|boolean>}\n     */\n    async multiMine(blockHeader, compact, minNonce, maxNonce) {}\n}\nClass.register(MinerWorker);\n","class MinerWorkerImpl extends IWorker.Stub(MinerWorker) {\n    constructor() {\n        super();\n        // FIXME: This is needed for Babel to work correctly. Can be removed as soon as we updated to Babel v7.\n        this._superInit = super.init;\n    }\n\n    async init(name) {\n        await this._superInit.call(this, name);\n\n        if (await this.importWasm('worker-wasm.wasm')) {\n            await this.importScript('worker-wasm.js');\n        } else {\n            await this.importScript('worker-js.js');\n        }\n    }\n\n    async multiMine(input, compact, minNonce, maxNonce) {\n        const hash = new Uint8Array(32);\n        let wasmOut, wasmIn;\n        try {\n            wasmOut = Module._malloc(hash.length);\n            wasmIn = Module._malloc(input.length);\n            Module.HEAPU8.set(input, wasmIn);\n            const nonce = Module._nimiq_argon2_target(wasmOut, wasmIn, input.length, compact, minNonce, maxNonce, 512);\n            if (nonce === maxNonce) return false;\n            hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hash.length));\n            return {hash, nonce};\n        } catch (e) {\n            Log.w(MinerWorkerImpl, e);\n            throw e;\n        } finally {\n            if (wasmOut !== undefined) Module._free(wasmOut);\n            if (wasmIn !== undefined) Module._free(wasmIn);\n        }\n    }\n}\n\nIWorker.prepareForWorkerUse(MinerWorker, new MinerWorkerImpl());\n","/**\n *\n */\nclass MinerWorkerPool extends IWorker.Pool(MinerWorker) {\n    constructor(size = 1) {\n        super((name) => IWorker.startWorkerForProxy(MinerWorker, name), 'miner', size);\n        /** @type {boolean} */\n        this._miningEnabled = false;\n        /** @type {Array.<{minNonce: number, maxNonce: number}>} */\n        this._activeNonces = [];\n        /** @type {Block} */\n        this._block = null;\n        /** @type {number} */\n        this._noncesPerRun = 256;\n        /** @type {Observable} */\n        this._observable = new Observable();\n        /** @type {number} */\n        this._shareCompact = Policy.BLOCK_TARGET_MAX;\n        /** @type {number} */\n        this._runsPerCycle = Infinity;\n        /** @type {number} */\n        this._cycleWait = 100;\n\n        // FIXME: This is needed for Babel to work correctly. Can be removed as soon as we updated to Babel v7.\n        this._superUpdateToSize = super._updateToSize;\n\n        if (PlatformUtils.isNodeJs()) {\n            const nimiq_node = require(`${__dirname}/nimiq_node`);\n            /**\n             * @param {SerialBuffer} blockHeader\n             * @param {number} compact\n             * @param {number} minNonce\n             * @param {number} maxNonce\n             * @returns {Promise.<{hash: Uint8Array, nonce: number}|boolean>}\n             */\n            this.multiMine = function (blockHeader, compact, minNonce, maxNonce) {\n                return new Promise((resolve, fail) => {\n                    nimiq_node.nimiq_argon2_target_async(async (nonce) => {\n                        try {\n                            if (nonce === maxNonce) {\n                                resolve(false);\n                            } else {\n                                blockHeader.writePos -= 4;\n                                blockHeader.writeUint32(nonce);\n                                const hash = await Crypto.argon2d(blockHeader);\n                                resolve({hash, nonce});\n                            }\n                        } catch (e) {\n                            fail(e);\n                        }\n                    }, blockHeader, compact, minNonce, maxNonce, 512);\n                });\n            };\n        }\n    }\n\n    /**\n     * @type {number}\n     */\n    get noncesPerRun() {\n        return this._noncesPerRun;\n    }\n\n    /**\n     * @param {number} nonces\n     */\n    set noncesPerRun(nonces) {\n        this._noncesPerRun = nonces;\n    }\n\n    /**\n     * @type {number}\n     */\n    get runsPerCycle() {\n        return this._runsPerCycle;\n    }\n\n    /**\n     * @param {number} runsPerCycle\n     */\n    set runsPerCycle(runsPerCycle) {\n        this._runsPerCycle = runsPerCycle;\n    }\n\n    /**\n     * @type {number}\n     */\n    get cycleWait() {\n        return this._cycleWait;\n    }\n\n    /**\n     * @param {number} cycleWait\n     */\n    set cycleWait(cycleWait) {\n        this._cycleWait = cycleWait;\n    }\n\n    /**\n     * @param {string} type\n     * @param {Function} callback\n     * @return {number}\n     */\n    on(type, callback) { this._observable.on(type, callback); }\n\n    /**\n     * @param {string} type\n     * @param {number} id\n     */\n    off(type, id) { this._observable.off(type, id); }\n\n    /**\n     * @param {Block} block\n     * @param {number} [shareCompact] target of a share, in compact format.\n     */\n    async startMiningOnBlock(block, shareCompact = block.nBits) {\n        this._block = block;\n        this._shareCompact = shareCompact;\n        if (!this._miningEnabled) {\n            await this._updateToSize();\n            this._activeNonces = [];\n            this._miningEnabled = true;\n            for (let i = 0; i < this.poolSize; ++i) {\n                this._startMiner();\n            }\n        } else {\n            this._activeNonces = [{minNonce:0, maxNonce:0}];\n        }\n    }\n\n    stop() {\n        this._miningEnabled = false;\n    }\n\n    async _updateToSize() {\n        if (!PlatformUtils.isNodeJs()) {\n            await this._superUpdateToSize.call(this);\n        }\n\n        while (this._miningEnabled && this._activeNonces.length < this.poolSize) {\n            this._startMiner();\n        }\n    }\n\n    _startMiner() {\n        const minNonce = this._activeNonces.length === 0 ? 0 : Math.max.apply(null, this._activeNonces.map((a) => a.maxNonce));\n        const maxNonce = minNonce + this._noncesPerRun;\n        const nonceRange = {minNonce, maxNonce};\n        this._activeNonces.push(nonceRange);\n        this._singleMiner(nonceRange).catch((e) => Log.e(MinerWorkerPool, e));\n    }\n\n    /**\n     * @param {{minNonce: number, maxNonce: number}} nonceRange\n     * @return {Promise.<void>}\n     * @private\n     */\n    async _singleMiner(nonceRange) {\n        let i = 0;\n        while (this._miningEnabled && (IWorker.areWorkersAsync || PlatformUtils.isNodeJs() || i === 0) && i < this._runsPerCycle) {\n            i++;\n            const block = this._block;\n            const result = await this.multiMine(block.header.serialize(), this._shareCompact, nonceRange.minNonce, nonceRange.maxNonce);\n            if (result) {\n                const hash = new Hash(result.hash);\n                this._observable.fire('share', {\n                    block,\n                    nonce: result.nonce,\n                    hash\n                });\n            } else {\n                this._observable.fire('no-share', {\n                    nonce: nonceRange.maxNonce\n                });\n            }\n            if (this._activeNonces.length > this.poolSize) {\n                this._activeNonces.splice(this._activeNonces.indexOf(nonceRange), 1);\n                return;\n            } else {\n                const newMin = Math.max.apply(null, this._activeNonces.map((a) => a.maxNonce));\n                const newRange = {minNonce: newMin, maxNonce: newMin + this._noncesPerRun};\n                this._activeNonces.splice(this._activeNonces.indexOf(nonceRange), 1, newRange);\n                nonceRange = newRange;\n            }\n        }\n        if (this._miningEnabled) {\n            setTimeout(() => this._singleMiner(nonceRange), this._cycleWait);\n        }\n    }\n}\n\nClass.register(MinerWorkerPool);\n","class ArrayUtils {\n    /**\n     * @template T\n     * @param {Array.<T>} arr\n     * @return {T}\n     */\n    static randomElement(arr) {\n        return arr[Math.floor(Math.random() * arr.length)];\n    }\n\n    /**\n     * @param {Uint8Array} uintarr\n     * @param {number} begin\n     * @param {number} end\n     * @return {Uint8Array}\n     */\n    static subarray(uintarr, begin, end) {\n        function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }\n\n        if (begin === undefined) { begin = 0; }\n        if (end === undefined) { end = uintarr.byteLength; }\n\n        begin = clamp(begin, 0, uintarr.byteLength);\n        end = clamp(end, 0, uintarr.byteLength);\n\n        let len = end - begin;\n        if (len < 0) {\n            len = 0;\n        }\n\n        return new Uint8Array(uintarr.buffer, uintarr.byteOffset + begin, len);\n    }\n\n    /**\n     * @param {Array} list\n     * @param {number} k\n     * @return {Generator}\n     */\n    static *k_combinations(list, k) {\n        const n = list.length;\n        // Shortcut:\n        if (k > n) {\n            return;\n        }\n        const indices = Array.from(new Array(k), (x,i) => i);\n        yield indices.map(i => list[i]);\n        const reverseRange = Array.from(new Array(k), (x,i) => k-i-1);\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n            let i = k-1, found = false;\n            for (i of reverseRange) {\n                if (indices[i] !== i + n - k) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return;\n            }\n            indices[i] += 1;\n            for (const j of Array.from(new Array(k-i-1), (x,k) => i+k+1)) {\n                indices[j] = indices[j-1] + 1;\n            }\n            yield indices.map(i => list[i]);\n        }\n    }\n}\nClass.register(ArrayUtils);\n","class Assert {\n    /**\n     * @param {boolean} condition\n     * @param {string} [message]\n     * @returns {void}\n     */\n    static that(condition, message = 'Assertion failed') {\n        if (!condition) throw new Error(message);\n    }\n}\nClass.register(Assert);\n","class MerkleTree {\n    /**\n     * @param {Array} values\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {Hash}\n     */\n    static computeRoot(values, fnHash = MerkleTree._hash) {\n        return MerkleTree._computeRoot(values, fnHash);\n    }\n\n    /**\n     * @param {Array} values\n     * @param {function(o: *):Hash} fnHash\n     * @returns {Hash}\n     * @private\n     */\n    static _computeRoot(values, fnHash) {\n        const len = values.length;\n        if (len === 0) {\n            return Hash.light(new Uint8Array(0));\n        }\n        if (len === 1) {\n            return fnHash(values[0]);\n        }\n\n        const mid = Math.round(len / 2);\n        const left = values.slice(0, mid);\n        const right = values.slice(mid);\n        const leftHash = MerkleTree._computeRoot(left, fnHash);\n        const rightHash = MerkleTree._computeRoot(right, fnHash);\n        return Hash.light(BufferUtils.concatTypedArrays(leftHash.serialize(), rightHash.serialize()));\n    }\n\n    /**\n     * @param {Hash|Uint8Array|{hash: function():Hash}|{serialize: function():Uint8Array}} o\n     * @returns {Hash}\n     * @private\n     */\n    static _hash(o) {\n        if (o instanceof Hash) {\n            return o;\n        }\n        if (typeof o.hash === 'function') {\n            return o.hash();\n        }\n        if (typeof o.serialize === 'function') {\n            return Hash.light(o.serialize());\n        }\n        if (o instanceof Uint8Array) {\n            return Hash.light(o);\n        }\n        throw new Error('MerkleTree objects must be Uint8Array or have a .hash()/.serialize() method');\n    }\n}\nClass.register(MerkleTree);\n","class MerklePath {\n    /**\n     * @param {Array.<MerklePathNode>} nodes\n     */\n    constructor(nodes) {\n        if (!Array.isArray(nodes) || !NumberUtils.isUint8(nodes.length)\n            || nodes.some(it => !(it instanceof MerklePathNode))) throw new Error('Malformed nodes');\n        /**\n         * @type {Array.<MerklePathNode>}\n         * @private\n         */\n        this._nodes = nodes;\n    }\n\n    /**\n     * @param {Array} values\n     * @param {*} leafValue\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {MerklePath}\n     */\n    static compute(values, leafValue, fnHash = MerkleTree._hash) {\n        const leafHash = fnHash(leafValue);\n        const path = [];\n        MerklePath._compute(values, leafHash, path, fnHash);\n        return new MerklePath(path);\n    }\n\n    /**\n     * @param {Array} values\n     * @param {Hash} leafHash\n     * @param {Array.<MerklePathNode>} path\n     * @param {function(o: *):Hash} fnHash\n     * @returns {{containsLeaf:boolean, inner:Hash}}\n     * @private\n     */\n    static _compute(values, leafHash, path, fnHash) {\n        const len = values.length;\n        let hash;\n        if (len === 0) {\n            hash = Hash.light(new Uint8Array(0));\n            return {containsLeaf: false, inner: hash};\n        }\n        if (len === 1) {\n            hash = fnHash(values[0]);\n            return {containsLeaf: hash.equals(leafHash), inner: hash};\n        }\n\n        const mid = Math.round(len / 2);\n        const left = values.slice(0, mid);\n        const right = values.slice(mid);\n        const {containsLeaf: leftLeaf, inner: leftHash} = MerklePath._compute(left, leafHash, path, fnHash);\n        const {containsLeaf: rightLeaf, inner: rightHash} = MerklePath._compute(right, leafHash, path, fnHash);\n        hash = Hash.light(BufferUtils.concatTypedArrays(leftHash.serialize(), rightHash.serialize()));\n\n        if (leftLeaf) {\n            path.push(new MerklePathNode(rightHash, false));\n            return {containsLeaf: true, inner: hash};\n        } else if (rightLeaf) {\n            path.push(new MerklePathNode(leftHash, true));\n            return {containsLeaf: true, inner: hash};\n        }\n\n        return {containsLeaf: false, inner: hash};\n    }\n\n    /**\n     * @param {*} leafValue\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {Hash}\n     */\n    computeRoot(leafValue, fnHash = MerkleTree._hash) {\n        /** @type {Hash} */\n        let root = fnHash(leafValue);\n        for (const node of this._nodes) {\n            const left = node.left;\n            const hash = node.hash;\n            const concat = new SerialBuffer(hash.serializedSize * 2);\n            if (left) hash.serialize(concat);\n            root.serialize(concat);\n            if (!left) hash.serialize(concat);\n            root = Hash.light(concat);\n        }\n        return root;\n    }\n\n    /**\n     * @param {Array.<MerklePathNode>} nodes\n     * @returns {Uint8Array}\n     * @private\n     */\n    static _compress(nodes) {\n        const count = nodes.length;\n        const leftBitsSize = Math.ceil(count / 8);\n        const leftBits = new Uint8Array(leftBitsSize);\n\n        for (let i = 0; i < count; i++) {\n            if (nodes[i].left) {\n                leftBits[Math.floor(i / 8)] |= 0x80 >>> (i % 8);\n            }\n        }\n\n        return leftBits;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {MerklePath}\n     */\n    static unserialize(buf) {\n        const count = buf.readUint8();\n        const leftBitsSize = Math.ceil(count / 8);\n        const leftBits = buf.read(leftBitsSize);\n\n        const nodes = [];\n        for (let i = 0; i < count; i++) {\n            const left = (leftBits[Math.floor(i / 8)] & (0x80 >>> (i % 8))) !== 0;\n            const hash = Hash.unserialize(buf);\n            nodes.push(new MerklePathNode(hash, left));\n        }\n        return new MerklePath(nodes);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._nodes.length);\n        buf.write(MerklePath._compress(this._nodes));\n\n        for (const node of this._nodes) {\n            node.hash.serialize(buf);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        const leftBitsSize = Math.ceil(this._nodes.length / 8);\n        return /*count*/ 1\n            + leftBitsSize\n            + this._nodes.reduce((sum, node) => sum + node.hash.serializedSize, 0);\n    }\n\n    /**\n     * @param {MerklePath} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof MerklePath\n            && this._nodes.length === o._nodes.length\n            && this._nodes.every((node, i) => node.equals(o._nodes[i]));\n    }\n\n    /** @type {Array.<MerklePathNode>} */\n    get nodes() {\n        return this._nodes;\n    }\n}\nClass.register(MerklePath);\n\nclass MerklePathNode {\n    /**\n     * @param {Hash} hash\n     * @param {boolean} left\n     */\n    constructor(hash, left) {\n        this._hash = hash;\n        this._left = left;\n    }\n\n    /** @type {Hash} */\n    get hash() {\n        return this._hash;\n    }\n\n    /** @type {boolean} */\n    get left() {\n        return this._left;\n    }\n\n    /**\n     * @param {MerklePathNode} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof MerklePathNode\n            && this._hash.equals(o.hash)\n            && this._left === o.left;\n    }\n}\nClass.register(MerklePathNode);\n","class Policy {\n    /**\n     * Convert Nimiq decimal to Number of Satoshis.\n     * @param {number} coins Nimiq count in decimal\n     * @return {number} Number of Satoshis\n     */\n    static coinsToSatoshis(coins) {\n        return Math.round(coins * Policy.SATOSHIS_PER_COIN);\n    }\n\n    /**\n     * Convert Number of Satoshis to Nimiq decimal.\n     * @param {number} satoshis Number of Satoshis.\n     * @return {number} Nimiq count in decimal.\n     */\n    static satoshisToCoins(satoshis) {\n        return satoshis / Policy.SATOSHIS_PER_COIN;\n    }\n\n    /**\n     * Circulating supply after block.\n     * @param {number} blockHeight\n     * @return {number}\n     */\n    static supplyAfter(blockHeight) {\n        // Calculate last entry in supply cache that is below blockHeight.\n        let startHeight = Math.floor(blockHeight / Policy._supplyCacheInterval) * Policy._supplyCacheInterval;\n        startHeight = Math.max(0, Math.min(startHeight, Policy._supplyCacheMax));\n\n        // Calculate respective block for the last entry of the cache and the targeted height.\n        const startI = startHeight / Policy._supplyCacheInterval;\n        const endI = Math.floor(blockHeight / Policy._supplyCacheInterval);\n\n        // The starting supply is the initial supply at the beginning and a cached value afterwards.\n        let supply = startHeight === 0 ? Policy.INITIAL_SUPPLY : Policy._supplyCache.get(startHeight);\n        // Use and update cache.\n        for (let i = startI; i < endI; ++i) {\n            startHeight = i * Policy._supplyCacheInterval;\n            // Since the cache stores the supply *before* a certain block, subtract one.\n            const endHeight = (i + 1) * Policy._supplyCacheInterval - 1;\n            supply = Policy._supplyAfter(supply, endHeight, startHeight);\n            // Don't forget to add one again.\n            Policy._supplyCache.set(endHeight + 1, supply);\n            Policy._supplyCacheMax = endHeight + 1;\n        }\n\n        // Calculate remaining supply (this also adds the block reward for endI*interval).\n        return Policy._supplyAfter(supply, blockHeight, endI * Policy._supplyCacheInterval);\n    }\n\n    /**\n     * Circulating supply after block.\n     * @param {number} initialSupply\n     * @param {number} blockHeight\n     * @param {number} [startHeight]\n     * @return {number}\n     */\n    static _supplyAfter(initialSupply, blockHeight, startHeight=0) {\n        let supply = initialSupply;\n        for (let i = startHeight; i <= blockHeight; ++i) {\n            supply += Policy._blockRewardAt(supply, i);\n        }\n        return supply;\n    }\n\n    /**\n     * Miner reward per block.\n     * @param {number} blockHeight\n     * @return {number}\n     */\n    static blockRewardAt(blockHeight) {\n        const currentSupply = Policy.supplyAfter(blockHeight - 1);\n        return Policy._blockRewardAt(currentSupply, blockHeight);\n    }\n\n    /**\n     * Miner reward per block.\n     * @param {number} currentSupply\n     * @param {number} blockHeight\n     * @return {number}\n     */\n    static _blockRewardAt(currentSupply, blockHeight) {\n        if (blockHeight <= 0) return 0;\n        const remaining = Policy.TOTAL_SUPPLY - currentSupply;\n        if (blockHeight >= Policy.EMISSION_TAIL_START && remaining >= Policy.EMISSION_TAIL_REWARD) {\n            return Policy.EMISSION_TAIL_REWARD;\n        }\n        const remainder = remaining % Policy.EMISSION_SPEED;\n        return (remaining - remainder) / Policy.EMISSION_SPEED;\n    }\n}\n\n/**\n * Targeted block time in seconds.\n * @type {number}\n * @constant\n */\nPolicy.BLOCK_TIME = 60;\n\n/**\n * Maximum block size in bytes.\n * @type {number}\n * @constant\n */\nPolicy.BLOCK_SIZE_MAX = 1e6; // 1 MB\n\n/**\n * The highest (easiest) block PoW target.\n * @type {number}\n * @constant\n */\nPolicy.BLOCK_TARGET_MAX = Math.pow(2, 240);\n\n/**\n * Number of blocks we take into account to calculate next difficulty.\n * @type {number}\n * @constant\n */\nPolicy.DIFFICULTY_BLOCK_WINDOW = 120;\n\n/**\n * Limits the rate at which the difficulty is adjusted min/max.\n * @type {number}\n * @constant\n */\nPolicy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR = 2;\n\n/**\n * Number of blocks a transaction is valid.\n * @type {number}\n * @constant\n */\nPolicy.TRANSACTION_VALIDITY_WINDOW = 120;\n\n\n/* Supply & Emission Parameters */\n\n/**\n * Number of Satoshis per Nimiq.\n * @type {number}\n * @constant\n */\nPolicy.SATOSHIS_PER_COIN = 1e5;\n\n/**\n * Targeted total supply in satoshis.\n * @type {number}\n * @constant\n */\nPolicy.TOTAL_SUPPLY = 21e14;\n\n/**\n * Initial supply before genesis block in satoshis.\n * FIXME: Change for main net.\n * @type {number}\n * @constant\n */\nPolicy.INITIAL_SUPPLY = 252000000000000;\n\n/**\n * Emission speed.\n * @type {number}\n * @constant\n */\nPolicy.EMISSION_SPEED = Math.pow(2, 22);\n\n/**\n * First block using constant tail emission until total supply is reached.\n * @type {number}\n * @constant\n */\nPolicy.EMISSION_TAIL_START = 48692960;\n\n/**\n * Constant tail emission in satoshis until total supply is reached.\n * @type {number}\n * @constant\n */\nPolicy.EMISSION_TAIL_REWARD = 4000;\n\n/* Security parameters */\n\n/**\n * NIPoPoW Security parameter M\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.M = 240;\n\n/**\n * NIPoPoW Security parameter K\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.K = 120;\n\n/**\n * NIPoPoW Security parameter DELTA\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.DELTA = 0.1;\n\n/**\n * Number of blocks the light client downloads to verify the AccountsTree construction.\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.NUM_BLOCKS_VERIFICATION = 250;\n\n\n/* Snapshot Parameters */\n\n/**\n * Maximum number of snapshots.\n * @type {number}\n * @constant\n */\nPolicy.NUM_SNAPSHOTS_MAX = 20;\n\n\n/**\n * Stores the circulating supply before the given block.\n * @type {Map.<number, number>}\n * @private\n */\nPolicy._supplyCache = new Map();\nPolicy._supplyCacheMax = 0; // blocks\nPolicy._supplyCacheInterval = 5000; // blocks\nClass.register(Policy);\n","/**\n * @abstract\n */\nclass Primitive {\n    /**\n     * @param arg\n     * @param type\n     * @param {?number} length\n     */\n    constructor(arg, type, length) {\n        if (type && !(arg instanceof type)) throw new Error('Primitive: Invalid type');\n        if (length !== undefined && arg.length !== undefined && arg.length !== length) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @param {Primitive} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Primitive && BufferUtils.equals(this.serialize(), o.serialize());\n    }\n\n    /**\n     * @param {Primitive} o\n     * @return {number} negative if this is smaller than o, positive if this is larger than o, zero if equal.\n     */\n    compare(o) {\n        if (typeof this._obj.compare === 'function') {\n            return this._obj.compare(o._obj);\n        } else if (this._obj.prototype === o._obj.prototype) {\n            return BufferUtils.compare(this.serialize(), o.serialize());\n        }\n\n        throw new Error(`Incomparable types: ${this._obj.constructor.name} and ${o._obj.constructor.name}`);\n    }\n\n    hashCode() {\n        return this.toBase64();\n    }\n\n    /**\n     * @abstract\n     * @param {SerialBuffer} [buf]\n     */\n    serialize(buf) {}\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        return this.toBase64();\n    }\n\n    /**\n     * @return {string}\n     */\n    toBase64() {\n        return BufferUtils.toBase64(this.serialize());\n    }\n\n    /**\n     * @return {string}\n     */\n    toHex() {\n        return BufferUtils.toHex(this.serialize());\n    }\n}\n\nClass.register(Primitive);\n","class Hash extends Primitive {\n    /**\n     * @param {Hash} o\n     * @returns {Hash}\n     */\n    static copy(o) {\n        if (!o) return o;\n        // FIXME Move this to Crypto class.\n        const obj = new Uint8Array(o._obj);\n        return new Hash(obj);\n    }\n\n    /**\n     * @param {?Uint8Array} arg\n     * @param {Hash.Algorithm} [algorithm]\n     * @private\n     */\n    constructor(arg, algorithm = Hash.Algorithm.BLAKE2B) {\n        if (arg === null) {\n            arg = new Uint8Array(Hash.getSize(algorithm));\n        }\n        super(arg, Crypto.hashType, Hash.getSize(algorithm));\n        /** @type {Hash.Algorithm} */\n        this._algorithm = algorithm;\n    }\n\n    /**\n     * @deprecated\n     * @param {Uint8Array} arr\n     * @returns {Hash}\n     */\n    static light(arr) {\n        return Hash.blake2b(arr);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Hash}\n     */\n    static blake2b(arr) {\n        return new Hash(Crypto.blake2bSync(arr), Hash.Algorithm.BLAKE2B);\n    }\n\n    /**\n     * @deprecated\n     * @param {Uint8Array} arr\n     * @returns {Promise.<Hash>}\n     */\n    static lightAsync(arr) {\n        return Hash.blake2bAsync(arr);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Promise.<Hash>}\n     */\n    static async blake2bAsync(arr) {\n        return new Hash(await Crypto.blake2bAsync(arr), Hash.Algorithm.BLAKE2B);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @deprecated\n     * @returns {Promise.<Hash>}\n     */\n    static hard(arr) {\n        return Hash.argon2d(arr);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Promise.<Hash>}\n     */\n    static async argon2d(arr) {\n        return new Hash(await Crypto.argon2d(arr), Hash.Algorithm.ARGON2D);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Hash}\n     */\n    static sha256(arr) {\n        return new Hash(Crypto.sha256(arr), Hash.Algorithm.SHA256);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @param {Hash.Algorithm} algorithm\n     * @returns {Hash}\n     */\n    static compute(arr, algorithm) {\n        switch (algorithm) {\n            case Hash.Algorithm.BLAKE2B: return Hash.blake2b(arr);\n            case Hash.Algorithm.SHA256: return Hash.sha256(arr);\n            // Hash.Algorithm.ARGON2 intentionally omitted\n            default: throw new Error('Invalid hash algorithm');\n        }\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @param {Hash.Algorithm} [algorithm]\n     * @returns {Hash}\n     */\n    static unserialize(buf, algorithm = Hash.Algorithm.BLAKE2B) {\n        return new Hash(buf.read(Hash.getSize(algorithm)), algorithm);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /**\n     * @param {number} begin\n     * @param {number} end\n     * @returns {Uint8Array}\n     */\n    subarray(begin, end) {\n        return this._obj.subarray(begin, end);\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return Hash.SIZE.get(this._algorithm);\n    }\n\n    /** @type {Uint8Array} */\n    get array() {\n        return this._obj;\n    }\n\n    /** @type {Hash.Algorithm} */\n    get algorithm() {\n        return this._algorithm;\n    }\n\n    /**\n     * @param {Primitive} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof Hash && o._algorithm === this._algorithm && super.equals(o);\n    }\n\n    /**\n     * @param {string} base64\n     * @returns {Hash}\n     */\n    static fromBase64(base64) {\n        return new Hash(BufferUtils.fromBase64(base64));\n    }\n\n    /**\n     * @param {string} hex\n     * @returns {Hash}\n     */\n    static fromHex(hex) {\n        return new Hash(BufferUtils.fromHex(hex));\n    }\n\n    static fromString(str) {\n        try {\n            return Hash.fromHex(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        try {\n            return Hash.fromBase64(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        throw new Error('Invalid hash format');\n    }\n\n    /**\n     * @param {Hash} o\n     * @returns {boolean}\n     */\n    static isHash(o) {\n        return o instanceof Hash;\n    }\n\n    /**\n     * @param {Hash.Algorithm} algorithm\n     * @returns {number}\n     */\n    static getSize(algorithm) {\n        const size = Hash.SIZE.get(algorithm);\n        if (!size) throw new Error('Invalid hash algorithm');\n        return size;\n    }\n}\n\n/**\n * @enum {number}\n */\nHash.Algorithm = {\n    BLAKE2B: 1,\n    ARGON2D: 2,\n    SHA256: 3\n};\n/**\n * @type {Map<Hash.Algorithm, number>}\n */\nHash.SIZE = new Map();\nHash.SIZE.set(Hash.Algorithm.BLAKE2B, Crypto.blake2bSize);\nHash.SIZE.set(Hash.Algorithm.ARGON2D, Crypto.argon2dSize);\nHash.SIZE.set(Hash.Algorithm.SHA256, Crypto.sha256Size);\n\nHash.NULL = new Hash(new Uint8Array(Crypto.hashSize));\nClass.register(Hash);\n","class PublicKey extends Primitive {\n    /**\n     * @param {PublicKey} o\n     * @returns {PublicKey}\n     */\n    static copy(o) {\n        if (!o) return o;\n        return new PublicKey(new Uint8Array(o._obj));\n    }\n\n    /**\n     * @param arg\n     * @private\n     */\n    constructor(arg) {\n        super(arg, Crypto.publicKeyType, Crypto.publicKeySize);\n    }\n\n    /**\n     * @param {PrivateKey} privateKey\n     * @return {PublicKey}\n     */\n    static derive(privateKey) {\n        return new PublicKey(Crypto.publicKeyDerive(privateKey._obj));\n    }\n\n    /**\n     * @param {Array.<PublicKey>} publicKeys\n     * @return {PublicKey}\n     */\n    static sum(publicKeys) {\n        publicKeys = publicKeys.slice();\n        publicKeys.sort((a, b) => a.compare(b));\n        return new PublicKey(Crypto.delinearizeAndAggregatePublicKeys(publicKeys.map(key => key._obj)));\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {PublicKey}\n     */\n    static unserialize(buf) {\n        return new PublicKey(Crypto.publicKeyUnserialize(buf.read(Crypto.publicKeySize)));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(Crypto.publicKeySerialize(this._obj));\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return Crypto.publicKeySize;\n    }\n\n    /**\n     * @param {Primitive} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof PublicKey && super.equals(o);\n    }\n\n    /**\n     * @return {Hash}\n     */\n    hash() {\n        return Hash.light(this.serialize());\n    }\n\n    /**\n     * @return {Promise.<Hash>}\n     */\n    hashAsync() {\n        return Hash.lightAsync(this.serialize());\n    }\n\n    /**\n     * @param {PublicKey} o\n     * @return {number}\n     */\n    compare(o) {\n        return BufferUtils.compare(this._obj, o._obj);\n    }\n\n    /**\n     * @return {Address}\n     */\n    toAddress() {\n        return Address.fromHash(this.hash());\n    }\n\n    /**\n     * @return {PeerId}\n     */\n    toPeerId() {\n        return new PeerId(this.hash().subarray(0, 16));\n    }\n}\n\nClass.register(PublicKey);\n","class Signature extends Primitive {\n    /**\n     * @param {Signature} o\n     * @returns {Signature}\n     */\n    static copy(o) {\n        if (!o) return o;\n        // FIXME Move this to Crypto class.\n        const obj = new Uint8Array(o._obj);\n        return new Signature(obj);\n    }\n\n    /**\n     * @param arg\n     * @private\n     */\n    constructor(arg) {\n        super(arg, Crypto.signatureType, Crypto.signatureSize);\n    }\n\n    /**\n     * @param {PrivateKey} privateKey\n     * @param {PublicKey} publicKey\n     * @param {Uint8Array} data\n     * @return {Signature}\n     */\n    static create(privateKey, publicKey, data) {\n        return new Signature(Crypto.signatureCreate(privateKey._obj, publicKey._obj, data));\n    }\n\n    /**\n     * @param {Commitment} commitment\n     * @param {Array.<PartialSignature>} signatures\n     * @return {Signature}\n     */\n    static fromPartialSignatures(commitment, signatures) {\n        return new Signature(Crypto.combinePartialSignatures(commitment._obj, signatures.map(s => s._obj)));\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Signature}\n     */\n    static unserialize(buf) {\n        return new Signature(Crypto.signatureUnserialize(buf.read(Crypto.signatureSize)));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(Crypto.signatureSerialize(this._obj));\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return Crypto.signatureSize;\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {Uint8Array} data\n     * @return {boolean}\n     */\n    verify(publicKey, data) {\n        return Crypto.signatureVerify(publicKey._obj, data, this._obj);\n    }\n\n    /**\n     * @param {Primitive} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Signature && super.equals(o);\n    }\n}\nClass.register(Signature);\n","class Address extends Primitive {\n    /**\n     * @param {Address} o\n     * @returns {Address}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const obj = new Uint8Array(o._obj);\n        return new Address(obj);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {Address}\n     */\n    static fromHash(hash) {\n        return new Address(hash.subarray(0, Address.SERIALIZED_SIZE));\n    }\n\n    constructor(arg) {\n        super(arg, Uint8Array, Address.SERIALIZED_SIZE);\n    }\n\n    /**\n     * Create Address object from binary form.\n     * @param {SerialBuffer} buf Buffer to read from.\n     * @return {Address} Newly created Account object.\n     */\n    static unserialize(buf) {\n        return new Address(buf.read(Address.SERIALIZED_SIZE));\n    }\n\n    /**\n     * Serialize this Address object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    subarray(begin, end) {\n        return this._obj.subarray(begin, end);\n    }\n\n    /**\n     * @type {number}\n     */\n    get serializedSize() {\n        return Address.SERIALIZED_SIZE;\n    }\n\n    /**\n     * @param {Primitive} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Address\n            && super.equals(o);\n    }\n\n    static fromString(str) {\n        try {\n            return Address.fromUserFriendlyAddress(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        try {\n            return Address.fromHex(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        try {\n            return Address.fromBase64(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        throw new Error('Invalid address format');\n    }\n\n    /**\n     * @param {string} base64\n     * @return {Address}\n     */\n    static fromBase64(base64) {\n        return new Address(BufferUtils.fromBase64(base64));\n    }\n\n    /**\n     * @param {string} hex\n     * @return {Address}\n     */\n    static fromHex(hex) {\n        return new Address(BufferUtils.fromHex(hex));\n    }\n\n    /**\n     * @param {string} str\n     * @return {Address}\n     */\n    static fromUserFriendlyAddress(str) {\n        str = str.replace(/ /g, '');\n        if (str.substr(0, 2).toUpperCase() !== Address.CCODE) {\n            throw new Error('Invalid Address: Wrong country code');\n        }\n        if (str.length !== 36) {\n            throw new Error('Invalid Address: Should be 36 chars (ignoring spaces)');\n        }\n        if (Address._ibanCheck(str.substr(4) + str.substr(0, 4)) !== 1) {\n            throw new Error('Invalid Address: Checksum invalid');\n        }\n        return new Address(BufferUtils.fromBase32(str.substr(4)));\n    }\n\n    static _ibanCheck(str) {\n        const num = str.split('').map((c) => {\n            const code = c.toUpperCase().charCodeAt(0);\n            return code >= 48 && code <= 57 ? c : (code - 55).toString();\n        }).join('');\n        let tmp = '';\n\n        for (let i = 0; i < Math.ceil(num.length / 6); i++) {\n            tmp = (parseInt(tmp + num.substr(i * 6, 6)) % 97).toString();\n        }\n\n        return parseInt(tmp);\n    }\n\n    /**\n     * @param {boolean} [withSpaces]\n     * @return {string}\n     */\n    toUserFriendlyAddress(withSpaces = true) {\n        const base32 = BufferUtils.toBase32(this.serialize());\n        // eslint-disable-next-line prefer-template\n        const check = ('00' + (98 - Address._ibanCheck(base32 + Address.CCODE + '00'))).slice(-2);\n        let res = Address.CCODE + check + base32;\n        if (withSpaces) res = res.replace(/.{4}/g, '$& ').trim();\n        return res;\n    }\n}\nAddress.CCODE = 'NQ';\nAddress.SERIALIZED_SIZE = 20;\nAddress.HEX_SIZE = 40;\nAddress.NULL = new Address(new Uint8Array(Address.SERIALIZED_SIZE));\nAddress.CONTRACT_CREATION = new Address(new Uint8Array(Address.SERIALIZED_SIZE));\nClass.register(Address);\n","/**\n * @abstract\n */\nclass Account {\n    /**\n     * @param {Account.Type} type\n     * @param {number} balance\n     */\n    constructor(type, balance) {\n        if (!NumberUtils.isUint8(type)) throw new Error('Malformed type');\n        if (!NumberUtils.isUint64(balance)) throw new Error('Malformed balance');\n\n        /** @type {Account.Type} */\n        this._type = type;\n        /** @type {number} */\n        this._balance = balance;\n    }\n\n    /**\n     * Create Account object from binary form.\n     * @param {SerialBuffer} buf Buffer to read from.\n     * @return {Account} Newly created Account object.\n     */\n    static unserialize(buf) {\n        const type = /** @type {Account.Type} */ buf.readUint8();\n        buf.readPos--;\n\n        if (!Account.TYPE_MAP.has(type)) {\n            throw new Error('Unknown account type');\n        }\n\n        return Account.TYPE_MAP.get(type).unserialize(buf);\n    }\n\n    /**\n     * Serialize this Account object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._type);\n        buf.writeUint64(this._balance);\n        return buf;\n    }\n\n    /**\n     * @return {number}\n     */\n    get serializedSize() {\n        return /*type*/ 1\n            + /*balance*/ 8;\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return BufferUtils.equals(this.serialize(), o.serialize());\n    }\n\n    toString() {\n        return `Account{type=${this._type}, balance=${this._balance.toString()}`;\n    }\n\n    /**\n     * @type {number} Account balance\n     */\n    get balance() {\n        return this._balance;\n    }\n\n    /** @type {Account.Type} */\n    get type() {\n        return this._type;\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) { throw new Error('Not yet implemented.'); }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionsCache\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert = false) {\n        if (!revert) {\n            const newBalance = this._balance - transaction.value - transaction.fee;\n            if (newBalance < 0) {\n                throw new Error('Balance Error!');\n            }\n            if (blockHeight < transaction.validityStartHeight\n                || blockHeight >= transaction.validityStartHeight + Policy.TRANSACTION_VALIDITY_WINDOW) {\n                throw new Error('Validity Error!');\n            }\n            if (transactionsCache.containsTransaction(transaction)) {\n                throw new Error('Double Transaction Error!');\n            }\n            return this.withBalance(newBalance);\n        } else {\n            if (blockHeight < transaction.validityStartHeight\n                || blockHeight >= transaction.validityStartHeight + Policy.TRANSACTION_VALIDITY_WINDOW) {\n                throw new Error('Validity Error!');\n            }\n            return this.withBalance(this._balance + transaction.value + transaction.fee);\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        if (!revert) {\n            return this.withBalance(this._balance + transaction.value);\n        } else {\n            const newBalance = this._balance - transaction.value;\n            if (newBalance < 0) {\n                throw new Error('Balance Error!');\n            }\n            return this.withBalance(newBalance);\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withContractCommand(transaction, blockHeight, revert = false) {\n        throw new Error('Not yet implemented');\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isInitial() {\n        return this === Account.INITIAL;\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isToBePruned() {\n        return this._balance === 0 && !this.isInitial();\n    }\n}\n\n/**\n * Enum for Account types.\n * Non-zero values are contracts.\n * @enum\n */\nAccount.Type = {\n    /**\n     * Basic account type.\n     * @see {BasicAccount}\n     */\n    BASIC: 0,\n    /**\n     * Account with vesting functionality.\n     * @see {VestingContract}\n     */\n    VESTING: 1,\n    /**\n     * Hashed Time-Locked Contract\n     * @see {HashedTimeLockedContract}\n     */\n    HTLC: 2\n};\n/**\n * @type {Map.<Account.Type, {copy: function(o: *):Account, unserialize: function(buf: SerialBuffer):Account, create: function(balance: number, blockHeight: number, transaction: Transaction):Account, verifyOutgoingTransaction: function(transaction: Transaction):Promise.<boolean>, verifyIncomingTransaction: function(transaction: Transaction):Promise.<boolean>}>}\n */\nAccount.TYPE_MAP = new Map();\n\nClass.register(Account);\n","class PrunedAccount {\n    /**\n     * @param {Address} address\n     * @param {Account} account\n     */\n    constructor(address, account) {\n        if (!(address instanceof Address)) throw new Error('Malformed address');\n\n        /** @type {Address} */\n        this._address = address;\n        /** @type {Account} */\n        this._account = account;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {PrunedAccount}\n     */\n    static unserialize(buf) {\n        return new PrunedAccount(Address.unserialize(buf), Account.unserialize(buf));\n    }\n\n    /**\n     * @param {PrunedAccount} o\n     * @return {number} negative if this is smaller than o, positive if this is larger than o, zero if equal.\n     */\n    compare(o) {\n        return this._address.compare(o._address);\n    }\n\n    /**\n     * @returns {Address}\n     */\n    get address() {\n        return this._address;\n    }\n\n    /**\n     * @returns {Account}\n     */\n    get account() {\n        return this._account;\n    }\n\n    /**\n     * @param buf\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._address.serialize(buf);\n        this._account.serialize(buf);\n        return this;\n    }\n\n    get serializedSize() {\n        return this._address.serializedSize + this._account.serializedSize;\n    }\n}\n\nClass.register(PrunedAccount);\n","/**\n * This is a classic account that can send all his funds and receive any transaction.\n * All outgoing transactions are signed using the key corresponding to this address.\n */\nclass BasicAccount extends Account {\n    /**\n     * @param {BasicAccount} o\n     * @returns {BasicAccount}\n     */\n    static copy(o) {\n        if (!o) return o;\n        return new BasicAccount(o._balance);\n    }\n\n    /**\n     * @param {number} [balance]\n     */\n    constructor(balance = 0) {\n        super(Account.Type.BASIC, balance);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {BasicAccount}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        if (type !== Account.Type.BASIC) throw new Error('Invalid account type');\n\n        const balance = buf.readUint64();\n        return new BasicAccount(balance);\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return o instanceof BasicAccount\n            && this._type === o._type\n            && this._balance === o._balance;\n    }\n\n    toString() {\n        return `BasicAccount{balance=${this._balance}}`;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyOutgoingTransaction(transaction) {\n        return SignatureProof.verifyTransaction(transaction);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        if (transaction.data.byteLength > 64) return false;\n        return true;\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) {\n        return new BasicAccount(balance);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        if (!revert) {\n            const isContractCreation = transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION);\n            const isTypeChange = transaction.recipientType !== this._type;\n            if (isContractCreation !== isTypeChange) {\n                throw new Error('Data Error!');\n            }\n        }\n        return super.withIncomingTransaction(transaction, blockHeight, revert);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withContractCommand(transaction, blockHeight, revert = false) {\n        if (!revert && transaction.recipientType !== this._type && transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION)) {\n            // Contract creation\n            return Account.TYPE_MAP.get(transaction.recipientType).create(this._balance, blockHeight, transaction);\n        }\n        return this;\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isInitial() {\n        return this._balance === 0;\n    }\n}\n\nAccount.INITIAL = new BasicAccount(0);\nAccount.TYPE_MAP.set(Account.Type.BASIC, BasicAccount);\nClass.register(BasicAccount);\n","class Contract extends Account {\n    /**\n     * @param {Account.Type} type\n     * @param {number} balance\n     */\n    constructor(type, balance) {\n        super(type, balance);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        if (!transaction.recipient.equals(transaction.getContractCreationAddress())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        if (!revert && transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION)) {\n            // Contract already created\n            throw new Error('Data error');\n        }\n        return super.withIncomingTransaction(transaction, blockHeight, revert);\n    }\n\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withContractCommand(transaction, blockHeight, revert = false) {\n        if (revert && transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION)) {\n            // Revert contract creation\n            return new BasicAccount(this.balance);\n        }\n        return this;\n    }\n}\n\nClass.register(Contract);\n","class HashedTimeLockedContract extends Contract {\n    /**\n     * @param {number} balance\n     * @param {Address} sender\n     * @param {Address} recipient\n     * @param {Hash} hashRoot\n     * @param {number} hashCount\n     * @param {number} timeout\n     * @param {number} totalAmount\n     */\n    constructor(balance = 0, sender = Address.NULL, recipient = Address.NULL, hashRoot = Hash.NULL, hashCount = 1, timeout = 0, totalAmount = balance) {\n        super(Account.Type.HTLC, balance);\n        if (!(sender instanceof Address)) throw new Error('Malformed address');\n        if (!(recipient instanceof Address)) throw new Error('Malformed address');\n        if (!(hashRoot instanceof Hash)) throw new Error('Malformed address');\n        if (!NumberUtils.isUint8(hashCount) || hashCount === 0) throw new Error('Malformed hashCount');\n        if (!NumberUtils.isUint32(timeout)) throw new Error('Malformed timeout');\n        if (!NumberUtils.isUint64(totalAmount)) throw new Error('Malformed totalAmount');\n\n        /** @type {Address} */\n        this._sender = sender;\n        /** @type {Address} */\n        this._recipient = recipient;\n        /** @type {Hash} */\n        this._hashRoot = hashRoot;\n        /** @type {number} */\n        this._hashCount = hashCount;\n        /** @type {number} */\n        this._timeout = timeout;\n        /** @type {number} */\n        this._totalAmount = totalAmount;\n    }\n\n    /**\n     * @param {number} balance\n     * @param {number} blockHeight\n     * @param {Transaction} transaction\n     */\n    static create(balance, blockHeight, transaction) {\n        const buf = new SerialBuffer(transaction.data);\n\n        const sender = Address.unserialize(buf);\n        const recipient = Address.unserialize(buf);\n        const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n        const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n        const hashCount = buf.readUint8();\n        const timeout = buf.readUint32();\n\n        return new HashedTimeLockedContract(balance, sender, recipient, hashRoot, hashCount, timeout);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {HashedTimeLockedContract}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        if (type !== Account.Type.HTLC) throw new Error('Invalid account type');\n\n        const balance = buf.readUint64();\n        const sender = Address.unserialize(buf);\n        const recipient = Address.unserialize(buf);\n        const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n        const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n        const hashCount = buf.readUint8();\n        const timeout = buf.readUint32();\n        const totalAmount = buf.readUint64();\n        return new HashedTimeLockedContract(balance, sender, recipient, hashRoot, hashCount, timeout, totalAmount);\n    }\n\n\n    /**\n     * Serialize this HTLC object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._sender.serialize(buf);\n        this._recipient.serialize(buf);\n        buf.writeUint8(this._hashRoot.algorithm);\n        this._hashRoot.serialize(buf);\n        buf.writeUint8(this._hashCount);\n        buf.writeUint32(this._timeout);\n        buf.writeUint64(this._totalAmount);\n        return buf;\n    }\n\n    /**\n     * @return {number}\n     */\n    get serializedSize() {\n        return super.serializedSize\n            + this._sender.serializedSize\n            + this._recipient.serializedSize\n            + /*hashAlgorithm*/ 1\n            + this._hashRoot.serializedSize\n            + /*hashCount*/ 1\n            + /*timeout*/ 4\n            + /*totalAmount*/ 8;\n    }\n\n    /** @type {Address} */\n    get sender() {\n        return this._sender;\n    }\n\n    /** @type {Address} */\n    get recipient() {\n        return this._recipient;\n    }\n\n    /** @type {Hash} */\n    get hashRoot() {\n        return this._hashRoot;\n    }\n\n    /** @type {number} */\n    get hashCount() {\n        return this._hashCount;\n    }\n\n    /** @type {number} */\n    get timeout() {\n        return this._timeout;\n    }\n\n    /** @type {number} */\n    get totalAmount() {\n        return this._totalAmount;\n    }\n\n    toString() {\n        return `HashedTimeLockedContract{balance=${this._balance}, sender=${this._sender.toUserFriendlyAddress(false)}, recipient=${this._sender.toUserFriendlyAddress(false)}, amount=${this._totalAmount}/${this._hashCount}, timeout=${this._timeout}}`;\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return o instanceof HashedTimeLockedContract\n            && this._type === o._type\n            && this._balance === o._balance\n            && this._sender.equals(o._sender)\n            && this._recipient.equals(o._recipient)\n            && this._hashRoot.equals(o._hashRoot)\n            && this._hashCount === o._hashCount\n            && this._timeout === o._timeout\n            && this._totalAmount === o._totalAmount;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyOutgoingTransaction(transaction) {\n        try {\n            const buf = new SerialBuffer(transaction.proof);\n            const type = buf.readUint8();\n            switch (type) {\n                case HashedTimeLockedContract.ProofType.REGULAR_TRANSFER: {\n                    const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n                    const hashDepth = buf.readUint8();\n                    const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n                    let preImage = Hash.unserialize(buf, hashAlgorithm);\n\n                    // Verify that the preImage hashed hashDepth times matches the _provided_ hashRoot.\n                    for (let i = 0; i < hashDepth; ++i) {\n                        preImage = Hash.compute(preImage.array, hashAlgorithm);\n                    }\n                    if (!hashRoot.equals(preImage)) {\n                        return false;\n                    }\n\n                    // Signature proof of the HTLC recipient\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n                    break;\n                }\n                case HashedTimeLockedContract.ProofType.EARLY_RESOLVE: {\n                    // Signature proof of the HTLC recipient\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n\n                    // Signature proof of the HTLC creator\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n                    break;\n                }\n                case HashedTimeLockedContract.ProofType.TIMEOUT_RESOLVE:\n                    // Signature proof of the HTLC creator\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n                    break;\n                default:\n                    return false;\n            }\n\n            // Reject overlong proof.\n            if (buf.readPos !== buf.byteLength) {\n                return false;\n            }\n\n            return true; // Accept\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        try {\n            const buf = new SerialBuffer(transaction.data);\n\n            Address.unserialize(buf); // sender address\n            Address.unserialize(buf); // recipient address\n            const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n            Hash.unserialize(buf, hashAlgorithm);\n            buf.readUint8(); // hash count\n            buf.readUint32(); // timeout\n\n            // Blacklist Argon2 hash function.\n            if (hashAlgorithm === Hash.Algorithm.ARGON2D) {\n                return false;\n            }\n\n            if (buf.readPos !== buf.byteLength) {\n                return false;\n            }\n\n            return Contract.verifyIncomingTransaction(transaction);\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) {\n        return new HashedTimeLockedContract(balance, this._sender, this._recipient, this._hashRoot, this._hashCount, this._timeout, this._totalAmount);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionsCache\n     * @param {boolean} [revert]\n     * @return {Account|*}\n     */\n    withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert = false) {\n        const buf = new SerialBuffer(transaction.proof);\n        const type = buf.readUint8();\n        let minCap = 0;\n        switch (type) {\n            case HashedTimeLockedContract.ProofType.REGULAR_TRANSFER: {\n                // Check that the contract has not expired yet.\n                if (this._timeout < blockHeight) {\n                    throw new Error('Proof Error!');\n                }\n\n                // Check that the provided hashRoot is correct.\n                const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n                const hashDepth = buf.readUint8();\n                const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n                if (!hashRoot.equals(this._hashRoot)) {\n                    throw new Error('Proof Error!');\n                }\n\n                // Ignore the preImage.\n                Hash.unserialize(buf, hashAlgorithm);\n\n                // Verify that the transaction is signed by the authorized recipient.\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._recipient)) {\n                    throw new Error('Proof Error!');\n                }\n\n                minCap = Math.max(0, Math.floor((1 - (hashDepth / this._hashCount)) * this._totalAmount));\n\n                break;\n            }\n            case HashedTimeLockedContract.ProofType.EARLY_RESOLVE: {\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._recipient)) {\n                    throw new Error('Proof Error!');\n                }\n\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._sender)) {\n                    throw new Error('Proof Error!');\n                }\n\n                break;\n            }\n            case HashedTimeLockedContract.ProofType.TIMEOUT_RESOLVE: {\n                if (this._timeout >= blockHeight) {\n                    throw new Error('Proof Error!');\n                }\n\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._sender)) {\n                    throw new Error('Proof Error!');\n                }\n\n                break;\n            }\n            default:\n                throw new Error('Proof Error!');\n        }\n\n        if (!revert) {\n            const newBalance = this._balance - transaction.value - transaction.fee;\n            if (newBalance < minCap) {\n                throw new Error('Balance Error!');\n            }\n        }\n\n        return super.withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert);\n    }\n\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        throw new Error('Illegal incoming transaction');\n    }\n}\n\nHashedTimeLockedContract.ProofType = {\n    REGULAR_TRANSFER: 1,\n    EARLY_RESOLVE: 2,\n    TIMEOUT_RESOLVE: 3\n};\n\nAccount.TYPE_MAP.set(Account.Type.HTLC, HashedTimeLockedContract);\nClass.register(HashedTimeLockedContract);\n","class VestingContract extends Contract {\n    /**\n     * @param {number} [balance]\n     * @param {Address} [owner]\n     * @param {number} [vestingStart]\n     * @param {number} [vestingStepBlocks]\n     * @param {number} [vestingStepAmount]\n     * @param {number} [vestingTotalAmount]\n     */\n    constructor(balance = 0, owner = Address.NULL, vestingStart = 0, vestingStepBlocks = 0, vestingStepAmount = balance, vestingTotalAmount = balance) {\n        super(Account.Type.VESTING, balance);\n        if (!(owner instanceof Address)) throw new Error('Malformed address');\n        if (!NumberUtils.isUint32(vestingStart)) throw new Error('Malformed vestingStart');\n        if (!NumberUtils.isUint32(vestingStepBlocks)) throw new Error('Malformed vestingStepBlocks');\n        if (!NumberUtils.isUint64(vestingStepAmount)) throw new Error('Malformed vestingStepAmount');\n        if (!NumberUtils.isUint64(vestingTotalAmount)) throw new Error('Malformed lowerCap');\n\n        /** @type {Address} */\n        this._owner = owner;\n        /** @type {number} */\n        this._vestingStart = vestingStart;\n        /** @type {number} */\n        this._vestingStepBlocks = vestingStepBlocks;\n        /** @type {number} */\n        this._vestingStepAmount = vestingStepAmount;\n        /** @type {number} */\n        this._vestingTotalAmount = vestingTotalAmount;\n    }\n\n    /**\n     * @param {number} balance\n     * @param {number} blockHeight\n     * @param {Transaction} transaction\n     */\n    static create(balance, blockHeight, transaction) {\n        /** @type {number} */\n        let vestingStart, vestingStepBlocks, vestingStepAmount, vestingTotalAmount;\n        const buf = new SerialBuffer(transaction.data);\n        const owner = Address.unserialize(buf);\n        vestingTotalAmount = transaction.value;\n        switch (transaction.data.length) {\n            case Address.SERIALIZED_SIZE + 4:\n                // Only block number: vest full amount at that block\n                vestingStart = 0;\n                vestingStepBlocks = buf.readUint32();\n                vestingStepAmount = vestingTotalAmount;\n                break;\n            case Address.SERIALIZED_SIZE + 16:\n                vestingStart = buf.readUint32();\n                vestingStepBlocks = buf.readUint32();\n                vestingStepAmount = buf.readUint64();\n                break;\n            case Address.SERIALIZED_SIZE + 24:\n                // Create a vesting account with some instantly vested funds or additional funds considered.\n                vestingStart = buf.readUint32();\n                vestingStepBlocks = buf.readUint32();\n                vestingStepAmount = buf.readUint64();\n                vestingTotalAmount = buf.readUint64();\n                break;\n            default:\n                throw new Error('Invalid transaction data');\n        }\n        return new VestingContract(balance, owner, vestingStart, vestingStepBlocks, vestingStepAmount, vestingTotalAmount);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {VestingContract}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        if (type !== Account.Type.VESTING) throw new Error('Invalid account type');\n\n        const balance = buf.readUint64();\n        const owner = Address.unserialize(buf);\n        const vestingStart = buf.readUint32();\n        const vestingStepBlocks = buf.readUint32();\n        const vestingStepAmount = buf.readUint64();\n        const vestingTotalAmount = buf.readUint64();\n        return new VestingContract(balance, owner, vestingStart, vestingStepBlocks, vestingStepAmount, vestingTotalAmount);\n    }\n\n    /**\n     * Serialize this VestingContract object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._owner.serialize(buf);\n        buf.writeUint32(this._vestingStart);\n        buf.writeUint32(this._vestingStepBlocks);\n        buf.writeUint64(this._vestingStepAmount);\n        buf.writeUint64(this._vestingTotalAmount);\n        return buf;\n    }\n\n    /**\n     * @return {number}\n     */\n    get serializedSize() {\n        return super.serializedSize\n            + this._owner.serializedSize\n            + /*vestingStart*/ 4\n            + /*vestingStepBlocks*/ 4\n            + /*vestingStepAmount*/ 8\n            + /*vestingTotalAmount*/ 8;\n    }\n\n    /** @type {Address} */\n    get owner() {\n        return this._owner;\n    }\n\n    /** @type {number} */\n    get vestingStart() {\n        return this._vestingStart;\n    }\n\n    /** @type {number} */\n    get vestingStepBlocks() {\n        return this._vestingStepBlocks;\n    }\n\n    /** @type {number} */\n    get vestingStepAmount() {\n        return this._vestingStepAmount;\n    }\n\n    /** @type {number} */\n    get vestingTotalAmount() {\n        return this._vestingTotalAmount;\n    }\n\n    toString() {\n        return `VestingAccount{balance=${this._balance}, owner=${this._owner.toUserFriendlyAddress()}`;\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return o instanceof VestingContract\n            && this._type === o._type\n            && this._balance === o._balance\n            && this._owner.equals(o._owner)\n            && this._vestingStart === o._vestingStart\n            && this._vestingStepBlocks === o._vestingStepBlocks\n            && this._vestingStepAmount === o._vestingStepAmount\n            && this._vestingTotalAmount === o._vestingTotalAmount;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyOutgoingTransaction(transaction) {\n        const buf = new SerialBuffer(transaction.proof);\n\n        if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n            return false;\n        }\n\n        if (buf.readPos !== buf.byteLength) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        switch (transaction.data.length) {\n            case Address.SERIALIZED_SIZE + 4:\n            case Address.SERIALIZED_SIZE + 16:\n            case Address.SERIALIZED_SIZE + 24:\n                return Contract.verifyIncomingTransaction(transaction);\n            default:\n                return false;\n        }\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) {\n        return new VestingContract(balance, this._owner, this._vestingStart, this._vestingStepBlocks, this._vestingStepAmount, this._vestingTotalAmount);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionsCache\n     * @param {boolean} [revert]\n     * @return {Account|*}\n     */\n    withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert = false) {\n        if (!revert) {\n            const minCap = this.getMinCap(blockHeight);\n            const newBalance = this._balance - transaction.value - transaction.fee;\n            if (newBalance < minCap) {\n                throw new Error('Balance Error!');\n            }\n\n            const buf = new SerialBuffer(transaction.proof);\n            if (!SignatureProof.unserialize(buf).isSignedBy(this._owner)) {\n                throw new Error('Proof Error!');\n            }\n        }\n        return super.withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        throw new Error('Illegal incoming transaction');\n    }\n\n    /**\n     * @param {number} blockHeight\n     * @returns {number}\n     */\n    getMinCap(blockHeight) {\n        return this._vestingStepBlocks && this._vestingStepAmount > 0\n            ? Math.max(0, this._vestingTotalAmount - Math.floor((blockHeight - this._vestingStart) / this._vestingStepBlocks) * this._vestingStepAmount)\n            : 0;\n    }\n}\n\nAccount.TYPE_MAP.set(Account.Type.VESTING, VestingContract);\nClass.register(VestingContract);\n","class BlockHeader {\n    /**\n     * @param {BlockHeader} o\n     * @returns {BlockHeader}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const prevHash = Hash.copy(o._prevHash);\n        const interlinkHash = Hash.copy(o._interlinkHash);\n        const bodyHash = Hash.copy(o._bodyHash);\n        const accountsHash = Hash.copy(o._accountsHash);\n        return new BlockHeader(\n            prevHash, interlinkHash, bodyHash, accountsHash,\n            o._nBits, o._height, o._timestamp, o._nonce, o._version\n        );\n    }\n\n    /**\n     * @param {Hash} prevHash\n     * @param {Hash} interlinkHash\n     * @param {Hash} bodyHash\n     * @param {Hash} accountsHash\n     * @param {number} nBits\n     * @param {number} height\n     * @param {number} timestamp\n     * @param {number} nonce\n     * @param {number} version\n     */\n    constructor(prevHash, interlinkHash, bodyHash, accountsHash, nBits, height, timestamp, nonce, version = BlockHeader.CURRENT_VERSION) {\n        if (!NumberUtils.isUint16(version)) throw 'Malformed version';\n        if (!Hash.isHash(prevHash)) throw 'Malformed prevHash';\n        if (!Hash.isHash(interlinkHash)) throw 'Malformed interlinkHash';\n        if (!Hash.isHash(bodyHash)) throw 'Malformed bodyHash';\n        if (!Hash.isHash(accountsHash)) throw 'Malformed accountsHash';\n        if (!NumberUtils.isUint32(nBits) || !BlockUtils.isValidCompact(nBits)) throw 'Malformed nBits';\n        if (!NumberUtils.isUint32(height)) throw 'Invalid height';\n        if (!NumberUtils.isUint32(timestamp)) throw 'Malformed timestamp';\n        if (!NumberUtils.isUint32(nonce)) throw 'Malformed nonce';\n\n        /** @type {number} */\n        this._version = version;\n        /** @type {Hash} */\n        this._prevHash = prevHash;\n        /** @type {Hash} */\n        this._interlinkHash = interlinkHash;\n        /** @type {Hash} */\n        this._bodyHash = bodyHash;\n        /** @type {Hash} */\n        this._accountsHash = accountsHash;\n        /** @type {number} */\n        this._nBits = nBits;\n        /** @type {number} */\n        this._height = height;\n        /** @type {number} */\n        this._timestamp = timestamp;\n        /** @type {number} */\n        this._nonce = nonce;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {BlockHeader}\n     */\n    static unserialize(buf) {\n        const version = buf.readUint16();\n        if (!BlockHeader.SUPPORTED_VERSIONS.includes(version)) throw new Error(`Unsupported block version ${version}`);\n        const prevHash = Hash.unserialize(buf);\n        const interlinkHash = Hash.unserialize(buf);\n        const bodyHash = Hash.unserialize(buf);\n        const accountsHash = Hash.unserialize(buf);\n        const nBits = buf.readUint32();\n        const height = buf.readUint32();\n        const timestamp = buf.readUint32();\n        const nonce = buf.readUint32();\n        return new BlockHeader(prevHash, interlinkHash, bodyHash, accountsHash, nBits, height, timestamp, nonce, version);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._version);\n        this._prevHash.serialize(buf);\n        this._interlinkHash.serialize(buf);\n        this._bodyHash.serialize(buf);\n        this._accountsHash.serialize(buf);\n        buf.writeUint32(this._nBits);\n        buf.writeUint32(this._height);\n        buf.writeUint32(this._timestamp);\n        buf.writeUint32(this._nonce);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*version*/ 2\n            + this._prevHash.serializedSize\n            + this._interlinkHash.serializedSize\n            + this._bodyHash.serializedSize\n            + this._accountsHash.serializedSize\n            + /*nBits*/ 4\n            + /*height*/ 4\n            + /*timestamp*/ 4\n            + /*nonce*/ 4;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {Promise.<boolean>}\n     */\n    async verifyProofOfWork(buf) {\n        const pow = await this.pow(buf);\n        return BlockUtils.isProofOfWork(pow, this.target);\n    }\n\n    /**\n     * @param {BlockHeader} prevHeader\n     * @returns {boolean}\n     */\n    isImmediateSuccessorOf(prevHeader) {\n        // Check that the height is one higher than the previous height.\n        if (this.height !== prevHeader.height + 1) {\n            return false;\n        }\n\n        // Check that the timestamp is greater or equal to the predecessor's timestamp.\n        if (this.timestamp < prevHeader.timestamp) {\n            return false;\n        }\n\n        // Check that the hash of the predecessor block equals prevHash.\n        const prevHash = prevHeader.hash();\n        if (!this.prevHash.equals(prevHash)) {\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {Hash}\n     */\n    hash(buf) {\n        this._hash = this._hash || Hash.light(this.serialize(buf));\n        return this._hash;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {Promise.<Hash>}\n     */\n    async hashAsync(buf) {\n        this._hash = this._hash || await Hash.lightAsync(this.serialize(buf));\n        return this._hash;\n    }\n    \n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {Promise.<Hash>}\n     */\n    async pow(buf) {\n        this._pow = this._pow || await Hash.hard(this.serialize(buf));\n        return this._pow;\n    }\n\n    /**\n     * @param {BlockHeader|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof BlockHeader\n            && this._prevHash.equals(o.prevHash)\n            && this._interlinkHash.equals(o.interlinkHash)\n            && this._bodyHash.equals(o.bodyHash)\n            && this._accountsHash.equals(o.accountsHash)\n            && this._nBits === o.nBits\n            && this._height === o.height\n            && this._timestamp === o.timestamp\n            && this._nonce === o.nonce;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return 'BlockHeader{'\n            + `prevHash=${this._prevHash}, `\n            + `interlinkHash=${this._interlinkHash}, `\n            + `bodyHash=${this._bodyHash}, `\n            + `accountsHash=${this._accountsHash}, `\n            + `nBits=${this._nBits.toString(16)}, `\n            + `height=${this._height}, `\n            + `timestamp=${this._timestamp}, `\n            + `nonce=${this._nonce}`\n            + '}';\n    }\n\n    /** @type {number} */\n    get version() {\n        return this._version;\n    }\n\n    /** @type {Hash} */\n    get prevHash() {\n        return this._prevHash;\n    }\n\n    /** @type {Hash} */\n    get interlinkHash() {\n        return this._interlinkHash;\n    }\n\n    /** @type {Hash} */\n    get bodyHash() {\n        return this._bodyHash;\n    }\n\n    /** @type {Hash} */\n    get accountsHash() {\n        return this._accountsHash;\n    }\n\n    /** @type {number} */\n    get nBits() {\n        return this._nBits;\n    }\n\n    /** @type {number} */\n    get target() {\n        return BlockUtils.compactToTarget(this._nBits);\n    }\n\n    /** @type {number} */\n    get difficulty() {\n        return BlockUtils.compactToDifficulty(this._nBits);\n    }\n\n    /** @type {number} */\n    get height() {\n        return this._height;\n    }\n\n    /** @type {number} */\n    get timestamp() {\n        return this._timestamp;\n    }\n\n    /** @type {number} */\n    get nonce() {\n        return this._nonce;\n    }\n\n    // XXX The miner changes the nonce of an existing BlockHeader during the\n    // mining process.\n    /** @type {number} */\n    set nonce(n) {\n        this._nonce = n;\n        this._hash = null;\n        this._pow = null;\n    }\n}\n// FIXME: Clean up for mainnet.\nBlockHeader.Version = {\n    V1: 1\n};\nBlockHeader.CURRENT_VERSION = BlockHeader.Version.V1;\nBlockHeader.SUPPORTED_VERSIONS = [\n    BlockHeader.Version.V1\n];\nBlockHeader.SERIALIZED_SIZE = 146;\nClass.register(BlockHeader);\n","class BlockInterlink {\n    /**\n     * @param {BlockInterlink} o\n     * @returns {BlockInterlink}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const hashes = o._hashes.map(it => Hash.copy(it));\n        const repeatBits = new Uint8Array(o._repeatBits);\n        const compressed = o._compressed.map(it => Hash.copy(it));\n        return new BlockInterlink(hashes, undefined, repeatBits, compressed);\n    }\n\n    /**\n     * @param {Array.<Hash>} hashes\n     * @param {Hash} prevHash\n     * @returns {{repeatBits: Uint8Array, compressed: Array.<Hash>}}\n     * @protected\n     */\n    static _compress(hashes, prevHash) {\n        const count = hashes.length;\n        const repeatBitsSize = Math.ceil(count / 8);\n        const repeatBits = new Uint8Array(repeatBitsSize);\n\n        let lastHash = prevHash;\n        const compressed = [];\n        for (let i = 0; i < count; i++) {\n            const hash = hashes[i];\n            if (!hash.equals(lastHash)) {\n                compressed.push(hash);\n                lastHash = hash;\n            } else {\n                repeatBits[Math.floor(i / 8)] |= 0x80 >>> (i % 8);\n            }\n        }\n\n        return {repeatBits, compressed};\n    }\n\n    /**\n     * @param {Array.<Hash>} hashes\n     * @param {Hash} [prevHash]\n     * @param {Uint8Array} [repeatBits]\n     * @param {Array.<Hash>} [compressed]\n     */\n    constructor(hashes, prevHash, repeatBits, compressed) {\n        if (!Array.isArray(hashes) || !NumberUtils.isUint8(hashes.length)\n            || hashes.some(it => !(it instanceof Hash))) throw new Error('Malformed hashes');\n        if ((repeatBits || compressed) && !(repeatBits && compressed)) throw new Error('Malformed repeatBits/compressed');\n        if (!prevHash && !repeatBits) throw new Error('Either prevHash or repeatBits/compressed required');\n\n        if (!repeatBits) {\n            ({repeatBits, compressed} = BlockInterlink._compress(hashes, prevHash));\n        }\n\n        /** @type {Array.<Hash>} */\n        this._hashes = hashes;\n        /** @type {Uint8Array} */\n        this._repeatBits = repeatBits;\n        /** @type {Array.<Hash>} */\n        this._compressed = compressed;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @param {Hash} prevHash\n     * @returns {BlockInterlink}\n     */\n    static unserialize(buf, prevHash) {\n        const count = buf.readUint8();\n        const repeatBitsSize = Math.ceil(count / 8);\n        const repeatBits = buf.read(repeatBitsSize);\n\n        let hash = prevHash;\n        const hashes = [];\n        const compressed = [];\n        for (let i = 0; i < count; i++) {\n            const repeated = (repeatBits[Math.floor(i / 8)] & (0x80 >>> (i % 8))) !== 0;\n            if (!repeated) {\n                hash = Hash.unserialize(buf);\n                compressed.push(hash);\n            }\n            hashes.push(hash);\n        }\n\n        return new BlockInterlink(hashes, prevHash, repeatBits, compressed);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._hashes.length);\n        buf.write(this._repeatBits);\n        for (const hash of this._compressed) {\n            hash.serialize(buf);\n        }\n        return buf;\n    }\n\n    /**\n     * @type {number}\n     */\n    get serializedSize() {\n        return /*count*/ 1\n            + this._repeatBits.length\n            + this._compressed.reduce((sum, hash) => sum + hash.serializedSize, 0);\n    }\n\n    /**\n     * @param {BlockInterlink|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof BlockInterlink\n            && this._hashes.length === o._hashes.length\n            && this._hashes.every((hash, i) => hash.equals(o.hashes[i]));\n    }\n\n    /**\n     * @returns {Hash}\n     */\n    hash() {\n        if (!this._hash) {\n            this._hash = MerkleTree.computeRoot([this._repeatBits, Block.GENESIS.HASH, ...this._compressed]);\n        }\n        return this._hash;\n    }\n\n    /**\n     * @type {Array.<Hash>}\n     */\n    get hashes() {\n        return this._hashes;\n    }\n\n    /**\n     * @type {number}\n     */\n    get length() {\n        return this._hashes.length;\n    }\n}\nClass.register(BlockInterlink);\n","class BlockBody {\n    /**\n     * @param {Uint8Array} extraData\n     * @returns {number}\n     */\n    static getMetadataSize(extraData) {\n        return Address.SERIALIZED_SIZE\n            + /*extraDataLength*/ 1\n            + extraData.byteLength\n            + /*transactionsLength*/ 2;\n    }\n\n    /**\n     * @param {Address} minerAddr\n     * @param {Array.<Transaction>} transactions\n     * @param {Uint8Array} [extraData]\n     * @param {Array.<PrunedAccount>} prunedAccounts\n     */\n    constructor(minerAddr, transactions, extraData = new Uint8Array(0), prunedAccounts = []) {\n        if (!(minerAddr instanceof Address)) throw 'Malformed minerAddr';\n        if (!Array.isArray(transactions) || transactions.some(it => !(it instanceof Transaction))) throw 'Malformed transactions';\n        if (!(extraData instanceof Uint8Array) || !NumberUtils.isUint8(extraData.byteLength)) throw 'Malformed extraData';\n\n        /** @type {Address} */\n        this._minerAddr = minerAddr;\n        /** @type {Uint8Array} */\n        this._extraData = extraData;\n        /** @type {Array.<Transaction>} */\n        this._transactions = transactions;\n        /** @type {Array.<PrunedAccount>} */\n        this._prunedAccounts = prunedAccounts;\n        /** @type {Hash} */\n        this._hash = null;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {BlockBody}\n     */\n    static unserialize(buf) {\n        const minerAddr = Address.unserialize(buf);\n        const extraDataLength = buf.readUint8();\n        const extraData = buf.read(extraDataLength);\n        const numTransactions = buf.readUint16();\n        const transactions = new Array(numTransactions);\n        for (let i = 0; i < numTransactions; i++) {\n            transactions[i] = Transaction.unserialize(buf);\n        }\n        const numPrunedAccounts = buf.readUint16();\n        const prunedAccounts = [];\n        for (let i = 0; i < numPrunedAccounts; i++) {\n            prunedAccounts.push(PrunedAccount.unserialize(buf));\n        }\n        return new BlockBody(minerAddr, transactions, extraData, prunedAccounts);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._minerAddr.serialize(buf);\n        buf.writeUint8(this._extraData.byteLength);\n        buf.write(this._extraData);\n        buf.writeUint16(this._transactions.length);\n        for (const tx of this._transactions) {\n            tx.serialize(buf);\n        }\n        buf.writeUint16(this._prunedAccounts.length);\n        for (const acc of this._prunedAccounts) {\n            acc.serialize(buf);\n        }\n        return buf;\n    }\n\n    /**\n     * @type {number}\n     */\n    get serializedSize() {\n        let size = this._minerAddr.serializedSize\n            + /*extraDataLength*/ 1\n            + this._extraData.byteLength\n            + /*transactionsLength*/ 2\n            + /*prunedAccountsLength*/ 2;\n        for (const tx of this._transactions) {\n            size += tx.serializedSize;\n        }\n        size += this._prunedAccounts.reduce((sum, acc) => sum + acc.serializedSize, 0);\n        return size;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    verify() {\n        /** @type {Transaction} */\n        let previousTx = null;\n        for (const tx of this._transactions) {\n            // Ensure transactions are ordered and unique.\n            if (previousTx && previousTx.compareBlockOrder(tx) >= 0) {\n                Log.w(BlockBody, 'Invalid block - transactions not ordered.');\n                return false;\n            }\n            previousTx = tx;\n\n            // Check that all transactions are valid.\n            if (!tx.verify()) {\n                Log.w(BlockBody, 'Invalid block - invalid transaction');\n                return false;\n            }\n        }\n\n        let previousAcc = null;\n        for (const acc of this._prunedAccounts) {\n            // Ensure pruned accounts are ordered and unique.\n            if (previousAcc && previousAcc.compare(acc) >= 0) {\n                Log.w(BlockBody, 'Invalid block - pruned accounts not ordered.');\n                return false;\n            }\n            previousAcc = acc;\n            \n            // Check that pruned accounts are actually supposed to be pruned\n            if (!acc.account.isToBePruned()) {\n                Log.w(BlockBody, 'Invalid block - invalid pruned account');\n                return false;\n            }\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {Array}\n     */\n    getMerkleLeafs() {\n        return [this._minerAddr, this._extraData, ...this._transactions, ...this.prunedAccounts];\n    }\n\n    /**\n     * @return {Hash}\n     */\n    hash() {\n        if (!this._hash) {\n            this._hash = MerkleTree.computeRoot(this.getMerkleLeafs());\n        }\n        return this._hash;\n    }\n\n    /**\n     * @param {BlockBody} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof BlockBody\n            && this._minerAddr.equals(o.minerAddr)\n            && BufferUtils.equals(this._extraData, o.extraData)\n            && this._transactions.length === o.transactions.length\n            && this._transactions.every((tx, i) => tx.equals(o.transactions[i]));\n    }\n\n    /**\n     * @return {Array.<Address>}\n     */\n    getAddresses() {\n        const addresses = [this._minerAddr];\n        for (const tx of this._transactions) {\n            addresses.push(tx.sender, tx.recipient);\n        }\n        return addresses;\n    }\n\n    /** @type {Uint8Array} */\n    get extraData() {\n        return this._extraData;\n    }\n\n    /** @type {Address} */\n    get minerAddr() {\n        return this._minerAddr;\n    }\n\n    /** @type {Array.<Transaction>} */\n    get transactions() {\n        return this._transactions;\n    }\n\n    /** @type {number} */\n    get transactionCount() {\n        return this._transactions.length;\n    }\n\n    /** @type {Array.<PrunedAccount>} */\n    get prunedAccounts() {\n        return this._prunedAccounts;\n    }\n}\n\nClass.register(BlockBody);\n","class BlockUtils {\n    /**\n     * @param {number} compact\n     * @returns {number}\n     */\n    static compactToTarget(compact) {\n        return (compact & 0xffffff) * Math.pow(2, (8 * ((compact >> 24) - 3)));\n    }\n\n    /**\n     * @param {number} target\n     * @returns {number}\n     */\n    static targetToCompact(target) {\n        if (!Number.isFinite(target) || Number.isNaN(target)) throw 'Invalid Target';\n\n        // Divide to get first byte\n        let size = Math.max(Math.ceil(Math.log2(target) / 8), 1);\n        const firstByte = target / Math.pow(2, (size - 1) * 8);\n\n        // If the first (most significant) byte is greater than 127 (0x7f),\n        // prepend a zero byte.\n        if (firstByte >= 0x80) {\n            size++;\n        }\n\n        // The first byte of the 'compact' format is the number of bytes,\n        // including the prepended zero if it's present.\n        // The following three bytes are the first three bytes of the above\n        // representation. If less than three bytes are present, then one or\n        // more of the last bytes of the compact representation will be zero.\n        return (size << 24) + ((target / Math.pow(2, (size - 3) * 8)) & 0xffffff);\n    }\n\n    /**\n     * @param {number} target\n     * @returns {number}\n     */\n    static getTargetHeight(target) {\n        return Math.ceil(Math.log2(target));\n    }\n\n    /**\n     * @param {number} target\n     * @returns {number}\n     */\n    static getTargetDepth(target) {\n        return BlockUtils.getTargetHeight(Policy.BLOCK_TARGET_MAX) - BlockUtils.getTargetHeight(target);\n    }\n\n    /**\n     * @param {number} compact\n     * @returns {number}\n     */\n    static compactToDifficulty(compact) {\n        return Policy.BLOCK_TARGET_MAX / BlockUtils.compactToTarget(compact);\n    }\n\n    /**\n     * @param {number} difficulty\n     * @returns {number}\n     */\n    static difficultyToCompact(difficulty) {\n        return BlockUtils.targetToCompact(BlockUtils.difficultyToTarget(difficulty));\n    }\n\n    /**\n     * @param {number} difficulty\n     * @returns {number}\n     */\n    static difficultyToTarget(difficulty) {\n        return Policy.BLOCK_TARGET_MAX / difficulty;\n    }\n\n    /**\n     * @param {number} target\n     * @returns {number}\n     */\n    static targetToDifficulty(target) {\n        return Policy.BLOCK_TARGET_MAX / target;\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {number}\n     */\n    static hashToTarget(hash) {\n        return parseInt(hash.toHex(), 16);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {number}\n     */\n    static realDifficulty(hash) {\n        return BlockUtils.targetToDifficulty(BlockUtils.hashToTarget(hash));\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {number} target\n     * @returns {boolean}\n     */\n    static isProofOfWork(hash, target) {\n        return parseInt(hash.toHex(), 16) <= target;\n    }\n\n    /**\n     * @param {number} compact\n     * @returns {boolean}\n     */\n\n    static isValidCompact(compact) {\n        return BlockUtils.isValidTarget(BlockUtils.compactToTarget(compact));\n    }\n\n    /**\n     * @param {number} target\n     * @returns {boolean}\n     */\n    static isValidTarget(target) {\n        return target >= 1 && target <= Policy.BLOCK_TARGET_MAX;\n    }\n\n    /**\n     * @param {BlockHeader} headBlock\n     * @param {BlockHeader} tailBlock\n     * @param {number} deltaTotalDifficulty\n     * @returns {number}\n     */\n    static getNextTarget(headBlock, tailBlock, deltaTotalDifficulty) {\n        Assert.that((headBlock.height - tailBlock.height === Policy.DIFFICULTY_BLOCK_WINDOW)\n            || (headBlock.height <= Policy.DIFFICULTY_BLOCK_WINDOW && tailBlock.height === 1),\n            `Tail and head block must be ${Policy.DIFFICULTY_BLOCK_WINDOW} blocks apart`);\n\n        let actualTime = headBlock.timestamp - tailBlock.timestamp;\n\n        // Simulate that the Policy.BLOCK_TIME was achieved for the blocks before the genesis block, i.e. we simulate\n        // a sliding window that starts before the genesis block. Assume difficulty = 1 for these blocks.\n        if (headBlock.height <= Policy.DIFFICULTY_BLOCK_WINDOW) {\n            actualTime += (Policy.DIFFICULTY_BLOCK_WINDOW - headBlock.height + 1) * Policy.BLOCK_TIME;\n            deltaTotalDifficulty += Policy.DIFFICULTY_BLOCK_WINDOW - headBlock.height + 1;\n        }\n\n        // Compute the target adjustment factor.\n        const expectedTime = Policy.DIFFICULTY_BLOCK_WINDOW * Policy.BLOCK_TIME;\n        let adjustment = actualTime / expectedTime;\n\n        // Clamp the adjustment factor to [1 / MAX_ADJUSTMENT_FACTOR, MAX_ADJUSTMENT_FACTOR].\n        adjustment = Math.max(adjustment, 1 / Policy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR);\n        adjustment = Math.min(adjustment, Policy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR);\n\n        // Compute the next target.\n        const averageDifficulty = deltaTotalDifficulty / Policy.DIFFICULTY_BLOCK_WINDOW;\n        const averageTarget = BlockUtils.difficultyToTarget(averageDifficulty);\n        let nextTarget = averageTarget * adjustment;\n\n        // Make sure the target is below or equal the maximum allowed target (difficulty 1).\n        // Also enforce a minimum target of 1.\n        nextTarget = Math.min(nextTarget, Policy.BLOCK_TARGET_MAX);\n        nextTarget = Math.max(nextTarget, 1);\n\n        // XXX Reduce target precision to nBits precision.\n        const nBits = BlockUtils.targetToCompact(nextTarget);\n        return BlockUtils.compactToTarget(nBits);\n    }\n}\nClass.register(BlockUtils);\n","class Block {\n    /**\n     * @param {Block} o\n     * @returns {Block}\n     */\n    static copy(o) {\n        if (!o) return o;\n        return new Block(\n            BlockHeader.copy(o._header),\n            BlockInterlink.copy(o._interlink),\n            BlockBody.copy(o._body)\n        );\n    }\n\n    /**\n     * @param {BlockHeader} header\n     * @param {BlockInterlink} interlink\n     * @param {BlockBody} [body]\n     */\n    constructor(header, interlink, body) {\n        if (!(header instanceof BlockHeader)) throw 'Malformed header';\n        if (!(interlink instanceof BlockInterlink)) throw 'Malformed interlink';\n        if (body && !(body instanceof BlockBody)) throw 'Malformed body';\n\n        /** @type {BlockHeader} */\n        this._header = header;\n        /** @type {BlockInterlink} */\n        this._interlink = interlink;\n        /** @type {BlockBody} */\n        this._body = body;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {Block}\n     */\n    static unserialize(buf) {\n        const header = BlockHeader.unserialize(buf);\n        const interlink = BlockInterlink.unserialize(buf, header.prevHash);\n\n        let body = undefined;\n        const bodyPresent = buf.readUint8();\n        if (bodyPresent) {\n            body = BlockBody.unserialize(buf);\n        }\n\n        return new Block(header, interlink, body);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._header.serialize(buf);\n        this._interlink.serialize(buf);\n\n        if (this._body) {\n            buf.writeUint8(1);\n            this._body.serialize(buf);\n        } else {\n            buf.writeUint8(0);\n        }\n\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this._header.serializedSize\n            + this._interlink.serializedSize\n            + /*bodyPresent*/ 1\n            + (this._body ? this._body.serializedSize : 0);\n    }\n\n    /**\n     * @param {Time} time\n     * @returns {Promise.<boolean>}\n     */\n    async verify(time) {\n        if (this._valid === undefined) {\n            if (this.isLight() || this.body.transactions.length < 150 || !IWorker.areWorkersAsync) {\n                // worker overhead doesn't pay off for small transaction numbers\n                this._valid = await this._verify(time.now());\n            } else {\n                const transactionValid = this.body.transactions.map(t => t._valid);\n                const {valid, pow, interlinkHash, bodyHash} = await Crypto.blockVerify(this.serialize(), transactionValid, time.now());\n                this._valid = valid;\n                this.header._pow = Hash.unserialize(new SerialBuffer(pow));\n                this.interlink._hash = Hash.unserialize(new SerialBuffer(interlinkHash));\n                this.body._hash = Hash.unserialize(new SerialBuffer(bodyHash));\n            }\n        }\n        return this._valid;\n    }\n\n    /**\n     * @param {number} timeNow\n     * @returns {Promise.<boolean>}\n     */\n    async _verify(timeNow) {\n        // Check that the timestamp is not too far into the future.\n        if (this._header.timestamp * 1000 > timeNow + Block.TIMESTAMP_DRIFT_MAX * 1000) {\n            Log.w(Block, 'Invalid block - timestamp too far in the future');\n            return false;\n        }\n\n        // Check that the header hash matches the difficulty.\n        if (!(await this._header.verifyProofOfWork())) {\n            Log.w(Block, 'Invalid block - PoW verification failed');\n            return false;\n        }\n\n        // Check that the maximum block size is not exceeded.\n        if (this.serializedSize > Policy.BLOCK_SIZE_MAX) {\n            Log.w(Block, 'Invalid block - max block size exceeded');\n            return false;\n        }\n\n        // Verify that the interlink is valid.\n        if (!this._verifyInterlink()) {\n            return false;\n        }\n\n        // XXX Verify the body only if it is present.\n        if (this.isFull() && !this._verifyBody()) {\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {boolean}\n     * @private\n     */\n    _verifyInterlink() {\n        // Skip check for genesis block due to the cyclic dependency (since the interlink hash contains the genesis block hash).\n        if (this.height === 1 && this._header.interlinkHash.equals(new Hash(null))) {\n            return true;\n        }\n\n        // Check that the interlinkHash given in the header matches the actual interlinkHash.\n        const interlinkHash = this._interlink.hash();\n        if (!this._header.interlinkHash.equals(interlinkHash)) {\n            Log.w(Block, 'Invalid block - interlink hash mismatch');\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {boolean}\n     * @private\n     */\n    _verifyBody() {\n        // Check that the body is valid.\n        if (!this._body.verify()) {\n            return false;\n        }\n\n        // Check that bodyHash given in the header matches the actual body hash.\n        const bodyHash = this._body.hash();\n        if (!this._header.bodyHash.equals(bodyHash)) {\n            Log.w(Block, 'Invalid block - body hash mismatch');\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {Block} predecessor\n     * @returns {Promise.<boolean>}\n     */\n    async isImmediateSuccessorOf(predecessor) {\n        // Check the header.\n        if (!this._header.isImmediateSuccessorOf(predecessor.header)) {\n            return false;\n        }\n\n        // Check that the interlink is correct.\n        const interlink = await predecessor.getNextInterlink(this.target, this.version);\n        if (!this._interlink.equals(interlink)) {\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {Block} predecessor\n     * @returns {Promise.<boolean>}\n     */\n    async isInterlinkSuccessorOf(predecessor) {\n        // Check that the height is higher than the predecessor's.\n        if (this._header.height <= predecessor.header.height) {\n            Log.v(Block, 'No interlink successor - height');\n            return false;\n        }\n\n        // Check that the timestamp is greater or equal to the predecessor's timestamp.\n        if (this._header.timestamp < predecessor.header.timestamp) {\n            Log.v(Block, 'No interlink successor - timestamp');\n            return false;\n        }\n\n        // Check that the predecessor is contained in this block's interlink and verify its position.\n        const prevHash = predecessor.hash();\n        if (!Block.GENESIS.HASH.equals(prevHash)) {\n            const prevPow = await predecessor.pow();\n            const targetHeight = BlockUtils.getTargetHeight(this.target);\n            let blockFound = false;\n\n            let depth = 0;\n            for (; depth < this._interlink.length; depth++) {\n                if (prevHash.equals(this._interlink.hashes[depth])) {\n                    blockFound = true;\n                    if (!BlockUtils.isProofOfWork(prevPow, Math.pow(2, targetHeight - depth))) {\n                        Log.v(Block, 'No interlink successor - invalid position in interlink');\n                        return false;\n                    }\n                }\n            }\n\n            if (!blockFound) {\n                Log.v(Block, 'No interlink successor - not in interlink');\n                return false;\n            }\n        }\n\n        // If the predecessor happens to be the immediate predecessor, check additionally:\n        // - that the height of the successor is one higher\n        // - that the interlink is correct.\n        if (this._header.prevHash.equals(prevHash)) {\n            if (this._header.height !== predecessor.header.height + 1) {\n                Log.v(Block, 'No interlink successor - immediate height');\n                return false;\n            }\n\n            const interlink = await predecessor.getNextInterlink(this.target, this.version);\n            const interlinkHash = interlink.hash();\n            if (!this._header.interlinkHash.equals(interlinkHash)) {\n                Log.v(Block, 'No interlink successor - immediate interlink');\n                return false;\n            }\n        }\n        // Otherwise, if the prevHash doesn't match but the blocks should be adjacent according to their height fields,\n        // this cannot be a valid successor of predecessor.\n        else if (this._header.height === predecessor.height.height + 1) {\n            Log.v(Block, 'No interlink successor - immediate height (2)');\n            return false;\n        }\n        // Otherwise, check that the interlink construction is valid given the information we have.\n        else {\n            // TODO Take different targets into account.\n\n            // The number of new blocks in the interlink is bounded by the height difference.\n            /** @type {HashSet.<Hash>} */\n            const hashes = new HashSet();\n            hashes.addAll(this._interlink.hashes);\n            hashes.removeAll(predecessor.interlink.hashes);\n            if (hashes.length > this._header.height - predecessor.header.height) {\n                Log.v(Block, 'No interlink successor - too many new blocks');\n                return false;\n            }\n\n            // Check that the interlink is not too short.\n            const thisDepth = BlockUtils.getTargetDepth(this.target);\n            const prevDepth = BlockUtils.getTargetDepth(predecessor.target);\n            const depthDiff = thisDepth - prevDepth;\n            if (this._interlink.length < predecessor.interlink.length - depthDiff) {\n                Log.v(Block, 'No interlink successor - interlink too short');\n                return false;\n            }\n\n            // If the same block is found in both interlinks, all blocks at lower depths must be the same in both interlinks.\n            let commonBlock = false;\n            const thisInterlink = this._interlink.hashes;\n            const prevInterlink = predecessor.interlink.hashes;\n            for (let i = 1; i < prevInterlink.length && i - depthDiff < thisInterlink.length; i++) {\n                if (prevInterlink[i].equals(thisInterlink[i - depthDiff])) {\n                    commonBlock = true;\n                }\n                else if (commonBlock) {\n                    Log.v(Block, 'No interlink successor - invalid common suffix');\n                    return false;\n                }\n            }\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {Block} predecessor\n     * @returns {Promise.<boolean>}\n     */\n    async isSuccessorOf(predecessor) {\n        // TODO Improve this! Lots of duplicate checks.\n        return (await this.isImmediateSuccessorOf(predecessor)) || (await this.isInterlinkSuccessorOf(predecessor));\n    }\n\n    /**\n     * @param {number} nextTarget\n     * @param {number} [nextVersion]\n     * @returns {Promise.<BlockInterlink>}\n     */\n    async getNextInterlink(nextTarget, nextVersion = BlockHeader.CURRENT_VERSION) {\n        // Compute the depth of this block relative to the next target.\n        const pow = await this.pow();\n        const thisPowDepth = BlockUtils.getTargetDepth(BlockUtils.hashToTarget(pow));\n        const nextTargetDepth = BlockUtils.getTargetDepth(nextTarget);\n        let depth = thisPowDepth - nextTargetDepth;\n\n        // Start constructing the next interlink.\n        /** @type {Array.<Hash>} */\n        const hashes = [];\n        const hash = this.hash();\n\n        // Push the current blockHash depth + 1 times onto the next interlink. If depth < 0, it won't be pushed.\n        for (let i = 0; i <= depth; i++) {\n            hashes.push(hash);\n        }\n\n        // Push the remaining hashes from the current interlink. If the target depth increases (i.e. the difficulty\n        // increases), we omit the block(s) at the beginning of the current interlink as they are not eligible for\n        // inclusion anymore.\n        const thisTargetDepth = BlockUtils.getTargetDepth(this.target);\n        const offset = nextTargetDepth - thisTargetDepth;\n        for (let j = depth + offset + 1; j < this.interlink.length; j++) {\n            hashes.push(this.interlink.hashes[j]);\n        }\n        \n        return new BlockInterlink(hashes, hash);\n    }\n\n    /**\n     * @param {Block|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof Block\n            && this._header.equals(o._header)\n            && this._interlink.equals(o._interlink)\n            && (this._body ? this._body.equals(o._body) : !o._body);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isLight() {\n        return !this._body;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isFull() {\n        return !!this._body;\n    }\n\n    /**\n     * @returns {Block}\n     */\n    toLight() {\n        return this.isLight() ? this : new Block(this._header, this._interlink);\n    }\n\n    /**\n     * @param {BlockBody} body\n     * @returns {Block}\n     */\n    toFull(body) {\n        return this.isFull() ? this : new Block(this._header, this._interlink, body);\n    }\n\n    /**\n     * @type {BlockHeader}\n     */\n    get header() {\n        return this._header;\n    }\n\n    /**\n     * @type {BlockInterlink}\n     */\n    get interlink() {\n        return this._interlink;\n    }\n\n    /**\n     * @type {BlockBody}\n     */\n    get body() {\n        if (this.isLight()) {\n            throw 'Cannot access body of light block';\n        }\n        return this._body;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get version() {\n        return this._header.version;\n    }\n\n    /**\n     * @type {Hash}\n     */\n    get prevHash() {\n        return this._header.prevHash;\n    }\n\n    /**\n     * @type {Hash}\n     */\n    get bodyHash() {\n        return this._header.bodyHash;\n    }\n\n    /**\n     * @type {Hash}\n     */\n    get accountsHash() {\n        return this._header.accountsHash;\n    }\n\n    /**\n     * @type {number}\n     */\n    get nBits() {\n        return this._header.nBits;\n    }\n\n    /**\n     * @type {number}\n     */\n    get target() {\n        return this._header.target;\n    }\n\n    /**\n     * @type {number}\n     */\n    get difficulty() {\n        return this._header.difficulty;\n    }\n\n    /**\n     * @type {number}\n     */\n    get height() {\n        return this._header.height;\n    }\n    \n    /**\n     * @type {number}\n     */\n    get timestamp() {\n        return this._header.timestamp;\n    }\n\n    /**\n     * @type {number}\n     */\n    get nonce() {\n        return this._header.nonce;\n    }\n\n    /**\n     * @type {Address}\n     */\n    get minerAddr() {\n        return this._body.minerAddr;\n    }\n\n    /**\n     * @type {Array.<Transaction>}\n     */\n    get transactions() {\n        return this._body.transactions;\n    }\n\n    /**\n     * @type {number}\n     */\n    get transactionCount() {\n        return this._body.transactionCount;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {Hash}\n     */\n    hash(buf) {\n        return this._header.hash(buf);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {Promise.<Hash>}\n     */\n    hashAsync(buf) {\n        return this._header.hashAsync(buf);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {Promise.<Hash>}\n     */\n    pow(buf) {\n        return this._header.pow(buf);\n    }\n\n}\nBlock.TIMESTAMP_DRIFT_MAX = 600 /* seconds */; // 10 minutes\nClass.register(Block);\n","/**\n * @abstract\n */\nclass Transaction {\n    /**\n     * @param {Transaction.Format} format\n     * @param {Address} sender\n     * @param {Account.Type} senderType\n     * @param {Address} recipient\n     * @param {Account.Type} recipientType\n     * @param {number} value\n     * @param {number} fee\n     * @param {number} validityStartHeight\n     * @param {Transaction.Flag | *} flags\n     * @param {Uint8Array} data\n     * @param {Uint8Array} proof\n     */\n    constructor(format, sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof) {\n        if (!(sender instanceof Address)) throw new Error('Malformed sender');\n        if (!NumberUtils.isUint8(senderType)) throw new Error('Malformed sender type');\n        if (!(recipient instanceof Address)) throw new Error('Malformed recipient');\n        if (!NumberUtils.isUint8(recipientType)) throw new Error('Malformed recipient type');\n        if (!NumberUtils.isUint64(value) || value === 0) throw new Error('Malformed value');\n        if (!NumberUtils.isUint64(fee)) throw new Error('Malformed fee');\n        if (!NumberUtils.isUint32(validityStartHeight)) throw new Error('Malformed validityStartHeight');\n        if (!NumberUtils.isUint8(flags) && (flags & ~(Transaction.Flag.ALL)) > 0) throw new Error('Malformed flags');\n        if (!(data instanceof Uint8Array) || !(NumberUtils.isUint16(data.byteLength))) throw new Error('Malformed data');\n        if (proof && (!(proof instanceof Uint8Array) || !(NumberUtils.isUint16(proof.byteLength)))) throw new Error('Malformed proof');\n\n        /** @type {Transaction.Format} */\n        this._format = format;\n        /** @type {Address} */\n        this._sender = sender;\n        /** @type {Account.Type} */\n        this._senderType = senderType;\n        /** @type {Address} */\n        this._recipient = recipient;\n        /** @type {Account.Type} */\n        this._recipientType = recipientType;\n        /** @type {number} */\n        this._value = value;\n        /** @type {number} */\n        this._fee = fee;\n        /** @type {number} */\n        this._validityStartHeight = validityStartHeight;\n        /** @type {Transaction.Flag | *} */\n        this._flags = flags;\n        /** @type {Uint8Array} */\n        this._data = data;\n        /** @type {Uint8Array} */\n        this._proof = proof;\n\n        if (this._recipient === Address.CONTRACT_CREATION) this._recipient = this.getContractCreationAddress();\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Transaction}\n     */\n    static unserialize(buf) {\n        const format = /** @type {Transaction.Format} */ buf.readUint8();\n        buf.readPos--;\n\n        if (!Transaction.FORMAT_MAP.has(format)) throw new Error('Invalid transaction type');\n        return Transaction.FORMAT_MAP.get(format).unserialize(buf);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serializeContent(buf) {\n        buf = buf || new SerialBuffer(this.serializedContentSize);\n        buf.writeUint16(this._data.byteLength);\n        buf.write(this._data);\n        this._sender.serialize(buf);\n        buf.writeUint8(this._senderType);\n        this._recipient.serialize(buf);\n        buf.writeUint8(this._recipientType);\n        buf.writeUint64(this._value);\n        buf.writeUint64(this._fee);\n        buf.writeUint32(this._validityStartHeight);\n        buf.writeUint8(this._flags);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedContentSize() {\n        return /*dataSize*/ 2\n            + this._data.byteLength\n            + this._sender.serializedSize\n            + /*senderType*/ 1\n            + this._recipient.serializedSize\n            + /*recipientType*/ 1\n            + /*value*/ 8\n            + /*fee*/ 8\n            + /*validityStartHeight*/ 4\n            + /*flags*/ 1;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    verify() {\n        if (this._valid === undefined) {\n            this._valid = this._verify();\n        }\n        return this._valid;\n    }\n\n    /**\n     * @returns {boolean}\n     * @private\n     */\n    _verify() {\n        // Check that sender != recipient.\n        if (this._recipient.equals(this._sender)) {\n            Log.w(Transaction, 'Sender and recipient must not match', this);\n            return false;\n        }\n        if (!Account.TYPE_MAP.has(this._senderType) || !Account.TYPE_MAP.has(this._recipientType)) {\n            Log.w(Transaction, 'Invalid account type', this);\n            return false;\n        }\n        if (!Account.TYPE_MAP.get(this._senderType).verifyOutgoingTransaction(this)) {\n            Log.w(Transaction, 'Invalid for sender', this);\n            return false;\n        }\n        if (!Account.TYPE_MAP.get(this._recipientType).verifyIncomingTransaction(this)) {\n            Log.w(Transaction, 'Invalid for recipient', this);\n            return false;\n        }\n        return true;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        throw new Error('Getter needs to be overwritten by subclasses');\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        throw new Error('Method needs to be overwritten by subclasses');\n    }\n\n    /**\n     * @return {Hash}\n     */\n    hash() {\n        // Exclude the signature, we don't want transactions to be malleable.\n        this._hash = this._hash || Hash.light(this.serializeContent());\n        return this._hash;\n    }\n\n    /**\n     * @return {Promise.<Hash>}\n     */\n    async hashAsync() {\n        // Exclude the signature, we don't want transactions to be malleable.\n        this._hash = this._hash || await Hash.lightAsync(this.serializeContent());\n        return this._hash;\n    }\n\n    /**\n     * @param {Transaction} o\n     * @return {number}\n     */\n    compare(o) {\n        if (this.fee / this.serializedSize > o.fee / o.serializedSize) return -1;\n        if (this.fee / this.serializedSize < o.fee / o.serializedSize) return 1;\n        if (this.serializedSize > o.serializedSize) return -1;\n        if (this.serializedSize < o.serializedSize) return 1;\n        if (this.fee > o.fee) return -1;\n        if (this.fee < o.fee) return 1;\n        if (this.value > o.value) return -1;\n        if (this.value < o.value) return 1;\n        return this.compareBlockOrder(o);\n    }\n\n    /**\n     * @param {Transaction} o\n     * @return {number}\n     */\n    compareBlockOrder(o) {\n        // This function must return 0 iff this.equals(o).\n        const recCompare = this._recipient.compare(o._recipient);\n        if (recCompare !== 0) return recCompare;\n        if (this._validityStartHeight < o._validityStartHeight) return -1;\n        if (this._validityStartHeight > o._validityStartHeight) return 1;\n        if (this._fee > o._fee) return -1;\n        if (this._fee < o._fee) return 1;\n        if (this._value > o._value) return -1;\n        if (this._value < o._value) return 1;\n        const senderCompare = this._sender.compare(o._sender);\n        if (senderCompare !== 0) return senderCompare;\n        if (this._recipientType < o._recipientType) return -1;\n        if (this._recipientType > o._recipientType) return 1;\n        if (this._senderType < o._senderType) return -1;\n        if (this._senderType > o._senderType) return 1;\n        if (this._flags < o._flags) return -1;\n        if (this._flags > o._flags) return 1;\n        return BufferUtils.compare(this._data, o._data);\n    }\n\n    /**\n     * @param {Transaction} o\n     * @return {boolean}\n     */\n    equals(o) {\n        // This ignores format and proof to be consistent with hash():\n        //   tx1.hash() == tx2.hash() iff tx1.equals(t2)\n        return o instanceof Transaction\n            && this._sender.equals(o._sender)\n            && this._senderType === o._senderType\n            && this._recipient.equals(o._recipient)\n            && this._recipientType === o._recipientType\n            && this._value === o._value\n            && this._fee === o._fee\n            && this._validityStartHeight === o._validityStartHeight\n            && this._flags === o._flags\n            && BufferUtils.equals(this._data, o._data);\n    }\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        return `Transaction{`\n            + `sender=${this._sender.toBase64()}, `\n            + `recipient=${this._recipient.toBase64()}, `\n            + `value=${this._value}, `\n            + `fee=${this._fee}, `\n            + `validityStartHeight=${this._validityStartHeight}`\n            + `}`;\n    }\n\n    /**\n     * @return {Address}\n     */\n    getContractCreationAddress() {\n        const tx = Transaction.unserialize(this.serialize());\n        tx._recipient = Address.NULL;\n        tx._hash = null;\n        return Address.fromHash(tx.hash());\n    }\n\n    /** @type {Address} */\n    get sender() {\n        return this._sender;\n    }\n\n    /** @type {Account.Type} */\n    get senderType() {\n        return this._senderType;\n    }\n\n    /** @type {Address} */\n    get recipient() {\n        return this._recipient;\n    }\n\n    /** @type {Account.Type} */\n    get recipientType() {\n        return this._recipientType;\n    }\n\n    /** @type {number} */\n    get value() {\n        return this._value;\n    }\n\n    /** @type {number} */\n    get fee() {\n        return this._fee;\n    }\n\n    /** @type {number} */\n    get feePerByte() {\n        return this._fee / this.serializedSize;\n    }\n\n    /** @type {number} */\n    get validityStartHeight() {\n        return this._validityStartHeight;\n    }\n\n    /** @type {number} */\n    get flags() {\n        return this._flags;\n    }\n\n    /**\n     * @param {Transaction.Flag} flag\n     * @returns {boolean}\n     */\n    hasFlag(flag) {\n        return (this._flags & flag) > 0;\n    }\n\n    /** @type {Uint8Array} */\n    get data() {\n        return this._data;\n    }\n\n    /** @type {Uint8Array} */\n    get proof() {\n        return this._proof;\n    }\n\n    // Sender proof is set by the Wallet after signing a transaction.\n    /** @type {Uint8Array} */\n    set proof(proof) {\n        this._proof = proof;\n    }\n}\n\n/**\n * Enum for Transaction formats.\n * @enum\n */\nTransaction.Format = {\n    BASIC: 0,\n    EXTENDED: 1\n};\n/**\n * @enum\n */\nTransaction.Flag = {\n    NONE: 0,\n    CONTRACT_CREATION: 0b1,\n    ALL: 0b1\n};\n/** @type {Map.<Transaction.Format, {unserialize: function(buf: SerialBuffer):Transaction}>} */\nTransaction.FORMAT_MAP = new Map();\n\nClass.register(Transaction);\n","class SignatureProof {\n    /**\n     * @param {Transaction} transaction\n     * @returns {boolean}\n     */\n    static verifyTransaction(transaction) {\n        try {\n            const buffer = new SerialBuffer(transaction.proof);\n            const proof = SignatureProof.unserialize(buffer);\n\n            // Reject proof if it is longer than needed.\n            if (buffer.readPos !== buffer.byteLength) {\n                Log.w(SignatureProof, 'Invalid SignatureProof - overlong');\n                return false;\n            }\n\n            return proof.verify(transaction.sender, transaction.serializeContent());\n        } catch (e) {\n            Log.w(SignatureProof, `Failed to verify transaction: ${e.message || e}`, e);\n            return false;\n        }\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {Signature} signature\n     * @returns {SignatureProof}\n     */\n    static singleSig(publicKey, signature) {\n        return new SignatureProof(publicKey, new MerklePath([]), signature);\n    }\n\n    /**\n     * @param {PublicKey} signerKey\n     * @param {Array.<PublicKey>} publicKeys\n     * @param {Signature} signature\n     * @returns {SignatureProof}\n     */\n    static multiSig(signerKey, publicKeys, signature) {\n        const merklePath = MerklePath.compute(publicKeys, signerKey);\n        return new SignatureProof(signerKey, merklePath, signature);\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {MerklePath} merklePath\n     * @param {Signature} signature\n     */\n    constructor(publicKey, merklePath, signature) {\n        if (!(publicKey instanceof PublicKey)) throw new Error('Malformed publickKey');\n        if (!(merklePath instanceof MerklePath)) throw new Error('Malformed merklePath');\n        if (signature && !(signature instanceof Signature)) throw new Error('Malformed signature');\n\n        /**\n         * @type {PublicKey}\n         * @private\n         */\n        this._publicKey = publicKey;\n        /**\n         * @type {MerklePath}\n         * @private\n         */\n        this._merklePath = merklePath;\n        /**\n         * @type {Signature}\n         * @private\n         */\n        this._signature = signature;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {SignatureProof}\n     */\n    static unserialize(buf) {\n        const publicKey = PublicKey.unserialize(buf);\n        const merklePath = MerklePath.unserialize(buf);\n        const signature = Signature.unserialize(buf);\n        return new SignatureProof(publicKey, merklePath, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._publicKey.serialize(buf);\n        this._merklePath.serialize(buf);\n\n        // The SignatureProof is sometimes serialized before the signature is set (e.g. when creating transactions).\n        // Simply don't serialize the signature if it's missing as this should never go over the wire.\n        // We always expect the signature to be present when unserializing.\n        if (this._signature) {\n            this._signature.serialize(buf);\n        }\n\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this._publicKey.serializedSize\n            + this._merklePath.serializedSize\n            + (this._signature ? this._signature.serializedSize : 0);\n    }\n\n    /**\n     * @param {SignatureProof} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof SignatureProof\n            && this._publicKey.equals(o._publicKey)\n            && this._merklePath.equals(o._merklePath)\n            && (this._signature ? this._signature.equals(o._signature) : this._signature === o._signature);\n    }\n\n    /**\n     * @param {?Address} sender\n     * @param {Uint8Array} data\n     * @returns {boolean}\n     */\n    verify(sender, data) {\n        if (sender !== null && !this.isSignedBy(sender)) {\n            Log.w(SignatureProof, 'Invalid SignatureProof - signer does not match sender address');\n            return false;\n        }\n\n        if (!this._signature) {\n            Log.w(SignatureProof, 'Invalid SignatureProof - signature is missing');\n            return false;\n        }\n\n        if (!this._signature.verify(this._publicKey, data)) {\n            Log.w(SignatureProof, 'Invalid SignatureProof - signature is invalid');\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {Address} sender\n     * @returns {boolean}\n     */\n    isSignedBy(sender) {\n        const merkleRoot = this._merklePath.computeRoot(this._publicKey);\n        const signerAddr = Address.fromHash(merkleRoot);\n        return signerAddr.equals(sender);\n    }\n\n    /** @type {PublicKey} */\n    get publicKey() {\n        return this._publicKey;\n    }\n\n    /** @type {MerklePath} */\n    get merklePath() {\n        return this._merklePath;\n    }\n\n    /** @type {Signature} */\n    get signature() {\n        return this._signature;\n    }\n\n    /** @type {Signature} */\n    set signature(signature) {\n        this._signature = signature;\n    }\n}\n\nClass.register(SignatureProof);\n","class BasicTransaction extends Transaction {\n    /**\n     * @param {PublicKey} senderPubKey\n     * @param {Address} recipient\n     * @param {number} value\n     * @param {number} fee\n     * @param {number} validityStartHeight\n     * @param {Signature} [signature]\n     */\n    constructor(senderPubKey, recipient, value, fee, validityStartHeight, signature) {\n        if (!(senderPubKey instanceof PublicKey)) throw new Error('Malformed senderPubKey');\n        // Signature may be initially empty and can be set later.\n        if (signature !== undefined && !(signature instanceof Signature)) throw new Error('Malformed signature');\n\n        const proof = SignatureProof.singleSig(senderPubKey, signature);\n        super(Transaction.Format.BASIC, senderPubKey.toAddress(), Account.Type.BASIC, recipient, Account.Type.BASIC, value, fee, validityStartHeight, Transaction.Flag.NONE, new Uint8Array(0), proof.serialize());\n\n        /**\n         * @type {SignatureProof}\n         * @private\n         */\n        this._signatureProof = proof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Transaction}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        Assert.that(type === Transaction.Format.BASIC);\n\n        const senderPubKey = PublicKey.unserialize(buf);\n        const recipient = Address.unserialize(buf);\n        const value = buf.readUint64();\n        const fee = buf.readUint64();\n        const validityStartHeight = buf.readUint32();\n        const signature = Signature.unserialize(buf);\n        return new BasicTransaction(senderPubKey, recipient, value, fee, validityStartHeight, signature);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(Transaction.Format.BASIC);\n        this.senderPubKey.serialize(buf);\n        this._recipient.serialize(buf);\n        buf.writeUint64(this._value);\n        buf.writeUint64(this._fee);\n        buf.writeUint32(this._validityStartHeight);\n        this.signature.serialize(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*type*/ 1\n            + this.senderPubKey.serializedSize\n            + this._recipient.serializedSize\n            + /*value*/ 8\n            + /*fee*/ 8\n            + /*validityStartHeight*/ 4\n            + this.signature.serializedSize;\n    }\n\n    /**\n     * @type {PublicKey}\n     */\n    get senderPubKey() {\n        return this._signatureProof.publicKey;\n    }\n\n    /**\n     * @type {Signature}\n     */\n    get signature() {\n        return this._signatureProof.signature;\n    }\n\n    /**\n     * @type {Signature}\n     */\n    set signature(signature) {\n        this._signatureProof.signature = signature;\n        this._proof = this._signatureProof.serialize();\n    }\n}\nTransaction.FORMAT_MAP.set(Transaction.Format.BASIC, BasicTransaction);\nClass.register(BasicTransaction);\n","class ExtendedTransaction extends Transaction {\n\n    /**\n     * @param {Address} sender\n     * @param {Account.Type} senderType\n     * @param {Address} recipient\n     * @param {Account.Type} recipientType\n     * @param {number} value\n     * @param {number} fee\n     * @param {number} validityStartHeight\n     * @param {Transaction.Flag | *} flags\n     * @param {Uint8Array} data\n     * @param {Uint8Array} [proof]\n     */\n    constructor(sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof = new Uint8Array(0)) {\n        super(Transaction.Format.EXTENDED, sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Transaction}\n     */\n    static unserialize(buf) {\n        const type = /** @type {Transaction.Format} */ buf.readUint8();\n        Assert.that(type === Transaction.Format.EXTENDED);\n\n        const dataSize = buf.readUint16();\n        const data = buf.read(dataSize);\n        const sender = Address.unserialize(buf);\n        const senderType = /** @type {Account.Type} */ buf.readUint8();\n        const recipient = Address.unserialize(buf);\n        const recipientType = /** @type {Account.Type} */ buf.readUint8();\n        const value = buf.readUint64();\n        const fee = buf.readUint64();\n        const validityStartHeight = buf.readUint32();\n        const flags = buf.readUint8();\n        const proofSize = buf.readUint16();\n        const proof = buf.read(proofSize);\n        return new ExtendedTransaction(sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(Transaction.Format.EXTENDED);\n        this.serializeContent(buf);\n        buf.writeUint16(this._proof.byteLength);\n        buf.write(this._proof);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*type*/ 1\n            + this.serializedContentSize\n            + /*proofSize*/ 2\n            + this._proof.byteLength;\n    }\n}\n\nTransaction.FORMAT_MAP.set(Transaction.Format.EXTENDED, ExtendedTransaction);\nClass.register(ExtendedTransaction);\n"]}